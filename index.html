<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Sector Zero - Phobia Tribute</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #050505;
            cursor: crosshair;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            user-select: none;
        }
        canvas { display: block; position: absolute; top: 0; left: 0; }
        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            pointer-events: none;
            color: #44ff44;
            text-shadow: 0 0 5px #005500;
            z-index: 10;
        }
        .bar-container {
            width: 300px;
            height: 20px;
            background: #111;
            border: 2px solid #333;
            margin-bottom: 5px;
            position: relative;
        }
        #health-bar {
            width: 100%;
            height: 100%;
            background: #ff3333;
            transition: width 0.1s;
        }
        #dash-bar {
            width: 100%;
            height: 100%;
            background: #ffffff;
            width: 100%; 
        }
        #focus-bar {
            width: 100%;
            height: 100%;
            background: #ffcc00;
            width: 100%; 
        }
        #grenade-bar {
            width: 100%;
            height: 100%;
            background: #3388ff;
            width: 100%; 
        }
        #score { font-size: 24px; font-weight: bold; }
        #wave { font-size: 18px; color: #888; margin-top: 5px; }
        #weapon-tag { font-size: 20px; color: #ffff00; margin-top: 10px; font-weight: bold; }
        #ammo-tag { font-size: 16px; color: #aaa; margin-left: 10px; }
        
        #game-over, #start-screen {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            z-index: 20;
            background: rgba(0, 10, 0, 0.95);
            padding: 40px;
            border: 2px solid #44ff44;
            color: #44ff44;
            box-shadow: 0 0 50px rgba(0, 255, 0, 0.2);
        }
        #game-over { display: none; }
        
        button {
            background: #003300;
            border: 1px solid #44ff44;
            color: #44ff44;
            padding: 15px 30px;
            font-size: 20px;
            cursor: pointer;
            text-transform: uppercase;
            margin-top: 20px;
            font-family: inherit;
        }
        button:hover { background: #44ff44; color: #000; }
        .label { font-size: 12px; color: #666; margin-bottom: 2px; margin-top: 5px;}
        .controls-hint { color: #888; font-size: 14px; margin-top: 10px; }
    </style>
</head>
<body>

    <canvas id="gameCanvas"></canvas>

    <div id="ui">
        <div class="label">ARMOR</div>
        <div class="bar-container">
            <div id="health-bar"></div>
        </div>
        <div class="label">FOCUS (SHIFT)</div>
        <div class="bar-container" style="height: 6px; width: 200px;">
            <div id="focus-bar"></div>
        </div>
        <div class="label">DASH (SPACE)</div>
        <div class="bar-container" style="height: 6px; width: 200px;">
            <div id="dash-bar"></div>
        </div>
        <div class="label">GRENADE (R-CLICK)</div>
        <div class="bar-container" style="height: 6px; width: 200px;">
            <div id="grenade-bar"></div>
        </div>
        <div id="score">KILLS: 0</div>
        <div id="wave">WAVE 1</div>
        <div style="display: flex; align-items: baseline;">
            <div id="weapon-tag">PISTOL</div>
            <div id="ammo-tag">∞</div>
        </div>
    </div>

    <div id="start-screen">
        <h1 style="font-size: 40px; margin: 0 0 10px 0;">SECTOR ZERO</h1>
        <p>SURVIVE THE HORDE</p>
        <div class="controls-hint">
            <p>WASD to Move | Mouse to Aim</p>
            <p>SHIFT (Hold) for Bullet Time</p>
            <p>SPACE to Dash | R-CLICK for Grenade</p>
            <p>Tip: Flank Tanks to hit their orange core!</p>
        </div>
        <button onclick="startGame()">INITIATE</button>
    </div>

    <div id="game-over">
        <h1 style="font-size: 40px; margin: 0 0 10px 0;">M.I.A.</h1>
        <p>SECTOR LOST</p>
        <p>CONFIRMED KILLS: <span id="final-score">0</span></p>
        <button onclick="restartGame()">REDEPLOY</button>
    </div>

<script>
    // -- AUDIO ENGINE --
    const Audio = (function() {
        let ctx = null;
        let enabled = false;

        function init() {
            if (!ctx) {
                ctx = new (window.AudioContext || window.webkitAudioContext)();
                enabled = true;
            }
            if (ctx.state === 'suspended') ctx.resume();
        }

        function playTone(freq, type, duration, vol = 0.1, ramp = true) {
            if (!enabled) return;
            const osc = ctx.createOscillator();
            const gain = ctx.createGain();
            osc.type = type;
            osc.frequency.setValueAtTime(freq, ctx.currentTime);
            if(ramp) osc.frequency.exponentialRampToValueAtTime(freq * 0.1, ctx.currentTime + duration);
            gain.gain.setValueAtTime(vol, ctx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + duration);
            osc.connect(gain);
            gain.connect(ctx.destination);
            osc.start();
            osc.stop(ctx.currentTime + duration);
        }

        function playNoise(duration, vol = 0.2) {
            if (!enabled) return;
            const bufferSize = ctx.sampleRate * duration;
            const buffer = ctx.createBuffer(1, bufferSize, ctx.sampleRate);
            const data = buffer.getChannelData(0);
            for (let i = 0; i < bufferSize; i++) {
                data[i] = Math.random() * 2 - 1;
            }
            const noise = ctx.createBufferSource();
            noise.buffer = buffer;
            const gain = ctx.createGain();
            gain.gain.setValueAtTime(vol, ctx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + duration);
            noise.connect(gain);
            gain.connect(ctx.destination);
            noise.start();
        }

        return {
            init,
            shoot: () => playTone(300 + Math.random()*100, 'square', 0.08, 0.03), 
            shotgun: () => { playTone(150, 'sawtooth', 0.2, 0.08); playNoise(0.2, 0.08); },
            rocket: () => { playTone(100, 'triangle', 0.5, 0.1); playNoise(0.5, 0.05); },
            explode: () => playNoise(0.5, 0.3),
            hit: () => playTone(100, 'sawtooth', 0.1, 0.05),
            crit: () => playTone(800, 'square', 0.1, 0.1), 
            dash: () => playTone(600, 'sine', 0.2, 0.05),
            pickup: () => playTone(800, 'sine', 0.2, 0.1, false),
            squish: () => { playNoise(0.05, 0.1); playTone(60, 'sine', 0.1, 0.15); }, 
            tankDeath: () => { playNoise(0.4, 0.3); playTone(50, 'square', 0.5, 0.2); },
            spawnTank: () => playTone(40, 'sawtooth', 1.5, 0.06, false), 
            spawnFlanker: () => playTone(600, 'triangle', 0.3, 0.05, true),
            spawnBlind: () => playNoise(0.5, 0.05),
        };
    })();

    // -- CHUNK MANAGER (OPTIMIZATION) --
    class ChunkManager {
        constructor(worldSize, chunkSize) {
            this.chunkSize = chunkSize;
            this.cols = Math.ceil(worldSize / chunkSize);
            this.rows = Math.ceil(worldSize / chunkSize);
            this.chunks = [];
            
            // Create grid of canvases
            for(let x = 0; x < this.cols; x++) {
                this.chunks[x] = [];
                for(let y = 0; y < this.rows; y++) {
                    const c = document.createElement('canvas');
                    c.width = chunkSize;
                    c.height = chunkSize;
                    this.chunks[x][y] = { canvas: c, ctx: c.getContext('2d') };
                }
            }
            this.reset();
        }

        reset() {
            // Draw grid on all chunks once
            for(let x = 0; x < this.cols; x++) {
                for(let y = 0; y < this.rows; y++) {
                    const ctx = this.chunks[x][y].ctx;
                    ctx.fillStyle = '#080808';
                    ctx.fillRect(0, 0, this.chunkSize, this.chunkSize);
                    
                    // Grid Lines
                    ctx.strokeStyle = '#121212';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    // Local coordinates for grid lines
                    const offsetX = x * this.chunkSize;
                    const offsetY = y * this.chunkSize;
                    
                    for(let gx=0; gx<=this.chunkSize; gx+=50) {
                        if ((gx + offsetX) % 50 === 0) {
                            ctx.moveTo(gx, 0); ctx.lineTo(gx, this.chunkSize);
                        }
                    }
                    for(let gy=0; gy<=this.chunkSize; gy+=50) {
                        if ((gy + offsetY) % 50 === 0) {
                            ctx.moveTo(0, gy); ctx.lineTo(this.chunkSize, gy);
                        }
                    }
                    ctx.stroke();
                }
            }
        }

        // Draw debris onto the specific chunk it belongs to
        drawDebris(x, y, rotation, color, w, h) {
            const cx = Math.floor(x / this.chunkSize);
            const cy = Math.floor(y / this.chunkSize);
            
            if(cx >= 0 && cx < this.cols && cy >= 0 && cy < this.rows) {
                const chunk = this.chunks[cx][cy];
                // Convert world coords to chunk local coords
                const localX = x - (cx * this.chunkSize);
                const localY = y - (cy * this.chunkSize);
                
                chunk.ctx.save();
                chunk.ctx.translate(localX, localY);
                chunk.ctx.rotate(rotation);
                chunk.ctx.fillStyle = color;
                chunk.ctx.globalAlpha = 0.5;
                chunk.ctx.fillRect(-w/2, -h/2, w, h);
                chunk.ctx.restore();
            }
        }

        // Render visible chunks to main canvas
        render(ctx, camera) {
            // Determine visible range
            const startCol = Math.floor(camera.x / this.chunkSize);
            const endCol = Math.floor((camera.x + ctx.canvas.width) / this.chunkSize);
            const startRow = Math.floor(camera.y / this.chunkSize);
            const endRow = Math.floor((camera.y + ctx.canvas.height) / this.chunkSize);

            for(let x = startCol; x <= endCol; x++) {
                for(let y = startRow; y <= endRow; y++) {
                    if(x >= 0 && x < this.cols && y >= 0 && y < this.rows) {
                        // Draw chunk at its world position relative to camera
                        const drawX = x * this.chunkSize;
                        const drawY = y * this.chunkSize;
                        ctx.drawImage(this.chunks[x][y].canvas, drawX, drawY);
                    }
                }
            }
        }
    }

    // -- GAME ENGINE --
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    
    // -- CONFIG --
    const WORLD_SIZE = 3000;
    const CHUNK_SIZE = 1000;
    const chunkManager = new ChunkManager(WORLD_SIZE, CHUNK_SIZE);

    const PLAYER_SPEED = 2.7; 
    const SPAWN_RATE = 1100; 
    const GRENADE_COOLDOWN = 3000; 
    const DASH_COOLDOWN = 1500;
    const DASH_DURATION = 150;
    const DASH_SPEED = 12;
    const MAX_PARTICLES = 200; 
    
    const ARENA_START_SIZE = 800; 
    const ARENA_GROWTH = 150;     

    // -- TIME SCALE --
    let timeScale = 1.0;
    let gameTime = 0; 
    const SLOW_MO_FACTOR = 0.2;
    const FOCUS_DRAIN = 0.5; 
    const FOCUS_REGEN = 0.2; 

    // -- WEAPONS --
    // UPDATED FIRE RATES & PISTOL DAMAGE
    const WEAPONS = {
        pistol: { name: 'PISTOL', tier: 1, rate: 400, speed: 12, damage: 2, spread: 0.02, count: 1, color: '#ffaa00', recoil: 2, ammo: Infinity },
        smg:    { name: 'SMG',    tier: 1, rate: 110, speed: 13, damage: 0.8, spread: 0.15, count: 1, color: '#ffffaa', recoil: 1, ammo: 80, maxAmmo: 80 },
        shotgun:{ name: 'SHOTGUN',tier: 1, rate: 850, speed: 11, damage: 1, spread: 0.35, count: 7, color: '#ffff00', recoil: 8, ammo: 24, maxAmmo: 24 },
        minigun:{ name: 'MINIGUN',tier: 2, rate: 55,  speed: 14, damage: 0.6, spread: 0.15, count: 1, color: '#00ffff', recoil: 1.5, ammo: 200, maxAmmo: 200 },
        rocket: { name: 'ROCKET', tier: 2, rate: 1200, speed: 8,  damage: 20, spread: 0,    count: 1, color: '#ff4444', recoil: 10, ammo: 10, maxAmmo: 10, explosive: true },
        railgun:{ name: 'RAILGUN',tier: 3, rate: 1500, speed: 30, damage: 10, spread: 0,    count: 1, color: '#ff00ff', recoil: 15, ammo: 12, maxAmmo: 12, pierce: true }
    };

    // -- STATE --
    let width, height;
    let camera = { x: 0, y: 0 };
    let player = { x: 0, y: 0, vx: 0, vy: 0, hp: 100, maxHp: 100, angle: 0, weapon: 'pistol', ammo: Infinity, focus: 100, maxFocus: 100 };
    let bullets = [];
    let grenades = [];
    let enemies = [];
    let particles = []; 
    let debris = [];    
    let pickups = [];
    
    let keys = { w: false, a: false, s: false, d: false, space: false, shift: false };
    let mouse = { x: 0, y: 0, left: false, right: false };
    
    // Timer Variables
    let lastShotTime = 0;
    let lastGrenadeTime = 0;
    let lastDashTime = 0;
    let lastSpawnTime = 0;
    
    let score = 0;
    let wave = 1;
    let isGameRunning = false;
    let shakeX = 0, shakeY = 0;
    let hitStop = 0;
    let noisePos = null; 
    
    let arena = { x: 0, y: 0, w: 0, h: 0, targetW: 0, targetH: 0 };

    // -- SETUP --
    function resize() {
        width = window.innerWidth;
        height = window.innerHeight;
        canvas.width = width;
        canvas.height = height;
    }
    window.addEventListener('resize', resize);
    window.addEventListener('contextmenu', e => e.preventDefault());

    function init() {
        resize();
        chunkManager.reset();
        
        player.x = WORLD_SIZE/2;
        player.y = WORLD_SIZE/2;
        player.hp = 100;
        player.focus = 100;
        player.weapon = 'pistol';
        player.ammo = Infinity;
        score = 0;
        wave = 1;
        gameTime = 0;
        
        arena.w = ARENA_START_SIZE;
        arena.h = ARENA_START_SIZE;
        arena.targetW = ARENA_START_SIZE;
        arena.targetH = ARENA_START_SIZE;
        arena.x = (WORLD_SIZE - arena.w) / 2;
        arena.y = (WORLD_SIZE - arena.h) / 2;
        
        bullets = [];
        grenades = [];
        enemies = [];
        particles = [];
        debris = [];
        pickups = [];
        
        isGameRunning = true;
        noisePos = null;
        
        // BUG FIX: Reset timers so actions work in new game
        lastGrenadeTime = -GRENADE_COOLDOWN; 
        lastDashTime = -DASH_COOLDOWN;
        lastShotTime = 0; 
        lastSpawnTime = 0;
        
        updateUI();
        document.getElementById('start-screen').style.display = 'none';
        document.getElementById('game-over').style.display = 'none';
        
        Audio.init();
        requestAnimationFrame(loop);
    }

    function startGame() { init(); }
    function restartGame() { init(); }

    function updateUI() {
        document.getElementById('health-bar').style.width = Math.max(0, player.hp) + '%';
        document.getElementById('score').innerText = 'KILLS: ' + score;
        document.getElementById('wave').innerText = 'WAVE ' + wave;
        document.getElementById('weapon-tag').innerText = WEAPONS[player.weapon].name;
        document.getElementById('ammo-tag').innerText = player.ammo === Infinity ? '∞' : player.ammo;
    }

    // Input Handlers
    const setKey = (k, v) => {
        if(k === 'w' || k === 'W') keys.w = v;
        if(k === 'a' || k === 'A') keys.a = v;
        if(k === 's' || k === 'S') keys.s = v;
        if(k === 'd' || k === 'D') keys.d = v;
        if(k === ' ' || k === 'Space') keys.space = v;
        if(k === 'Shift') keys.shift = v;
    };
    window.addEventListener('keydown', e => setKey(e.key, true));
    window.addEventListener('keyup', e => setKey(e.key, false));
    window.addEventListener('mousemove', e => { mouse.x = e.clientX; mouse.y = e.clientY; });
    window.addEventListener('mousedown', (e) => {
        if (e.button === 0) mouse.left = true;
        if (e.button === 2) mouse.right = true;
    });
    window.addEventListener('mouseup', (e) => {
        if (e.button === 0) mouse.left = false;
        if (e.button === 2) mouse.right = false;
    });

    function setWeapon(type) {
        player.weapon = type;
        player.ammo = WEAPONS[type].ammo;
        updateUI();
        Audio.pickup();
    }

    function normalizeAngle(angle) {
        while (angle > Math.PI) angle -= Math.PI * 2;
        while (angle < -Math.PI) angle += Math.PI * 2;
        return angle;
    }

    // -- CLASSES --
    class Bullet {
        constructor(x, y, angle, speed, color, damage, explosive = false, pierce = false) {
            this.x = x; this.y = y;
            this.vx = Math.cos(angle) * speed;
            this.vy = Math.sin(angle) * speed;
            this.life = 60;
            this.color = color;
            this.damage = damage;
            this.angle = angle;
            this.explosive = explosive;
            this.pierce = pierce;
            this.hitList = []; 
        }
        update(dt) {
            this.x += this.vx * dt;
            this.y += this.vy * dt;
            this.life -= 1 * dt;
        }
        draw(ctx) {
            ctx.save();
            ctx.translate(this.x, this.y);
            ctx.rotate(this.angle);
            ctx.fillStyle = this.color;
            if (this.pierce) {
                ctx.fillStyle = '#ffffff';
                ctx.fillRect(-20, -1, 40, 2);
                ctx.fillStyle = this.color;
                ctx.globalAlpha = 0.5;
                ctx.fillRect(-20, -3, 40, 6);
            } else if (this.explosive) {
                ctx.fillRect(-8, -3, 16, 6);
                ctx.fillStyle = '#ff8800';
                ctx.fillRect(-8, -1, 4, 2); 
            } else {
                ctx.fillRect(-6, -2, 12, 4);
            }
            ctx.restore();
        }
    }

    class Grenade {
        constructor(x, y, angle) {
            this.x = x; this.y = y;
            this.vx = Math.cos(angle) * 10;
            this.vy = Math.sin(angle) * 10;
            this.life = 60; 
            this.radius = 6;
        }
        update(dt) {
            this.x += this.vx * dt;
            this.y += this.vy * dt;
            this.vx *= (1 - (0.05 * dt)); 
            this.vy *= (1 - (0.05 * dt));
            this.life -= 1 * dt;
        }
        draw(ctx) {
            ctx.fillStyle = '#4488ff';
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.radius, 0, Math.PI*2);
            ctx.fill();
            if (Math.floor(Date.now() / 100) % 2 === 0) {
                ctx.fillStyle = '#fff';
                ctx.beginPath();
                ctx.arc(this.x+2, this.y-2, 2, 0, Math.PI*2);
                ctx.fill();
            }
        }
    }

    class Pickup {
        constructor(x, y, type) {
            this.x = x; this.y = y;
            this.type = type; 
            this.life = 900; 
            this.bob = 0;
        }
        update(dt) {
            this.life -= 1 * dt;
            this.bob += 0.1 * dt;
        }
        draw(ctx) {
            const yOff = Math.sin(this.bob) * 3;
            ctx.save();
            ctx.translate(this.x, this.y + yOff);
            
            if (this.type === 'medikit') {
                ctx.fillStyle = '#fff';
                ctx.fillRect(-10, -10, 20, 20);
                ctx.fillStyle = '#00ff00';
                ctx.fillRect(-3, -8, 6, 16);
                ctx.fillRect(-8, -3, 16, 6);
            } else {
                const w = WEAPONS[this.type];
                ctx.fillStyle = '#222';
                ctx.fillRect(-12, -8, 24, 16);
                ctx.fillStyle = w.color;
                ctx.font = '10px Arial';
                ctx.fillText(w.name.substring(0,2), -8, 4);
                ctx.strokeStyle = w.color;
                ctx.strokeRect(-12, -8, 24, 16);
            }
            ctx.restore();
        }
    }

    class Debris {
        constructor(x, y, color) {
            this.x = x; this.y = y;
            const angle = Math.random() * Math.PI * 2;
            const speed = Math.random() * 8 + 2;
            this.vx = Math.cos(angle) * speed;
            this.vy = Math.sin(angle) * speed;
            this.rotation = Math.random() * Math.PI * 2;
            this.rotSpeed = (Math.random() - 0.5) * 0.5;
            this.life = 1.0;
            this.color = color;
            this.size = 4 + Math.random() * 6;
            this.w = this.size;
            this.h = this.size * 0.6; 
        }
        update(dt) {
            this.x += this.vx * dt;
            this.y += this.vy * dt;
            this.vx *= (1 - (0.1 * dt)); 
            this.vy *= (1 - (0.1 * dt));
            this.rotation += this.rotSpeed * dt;
            this.rotSpeed *= (1 - (0.05 * dt));
            
            if (Math.abs(this.vx) < 0.1 && Math.abs(this.vy) < 0.1) {
                this.life -= 0.05 * dt; 
            }
        }
        draw(ctx) {
            ctx.save();
            ctx.translate(this.x, this.y);
            ctx.rotate(this.rotation);
            ctx.fillStyle = this.color;
            ctx.fillRect(-this.w/2, -this.h/2, this.w, this.h);
            ctx.restore();
        }
    }

    class Enemy {
        constructor(typeOverride) {
            this.type = 'zombie';
            this.facing = 0; 
            this.dead = false; // Add Dead flag for safe removal
            
            if (typeOverride) {
                this.type = typeOverride;
            } else {
                const r = Math.random();
                if (wave < 5) {
                    this.type = 'zombie';
                } else if (wave < 10) {
                    this.type = r < 0.3 ? 'flanker' : 'zombie';
                    if (wave > 7 && r < 0.05) this.type = 'tank';
                } else {
                    if (r < 0.4) this.type = 'zombie';
                    else if (r < 0.7) this.type = 'flanker';
                    else if (r < 0.9) this.type = 'blind';
                    else this.type = 'tank';
                }
            }

            if (this.type === 'tank') Audio.spawnTank();
            else if (this.type === 'flanker') Audio.spawnFlanker();
            else if (this.type === 'blind') Audio.spawnBlind();

            const buffer = 40;
            if (Math.random() < 0.5) {
                this.x = arena.x + Math.random() * arena.w;
                this.y = Math.random() < 0.5 ? arena.y - buffer : arena.y + arena.h + buffer;
            } else {
                this.x = Math.random() < 0.5 ? arena.x - buffer : arena.x + arena.w + buffer;
                this.y = arena.y + Math.random() * arena.h;
            }

            this.vx = 0; this.vy = 0;
            
            switch(this.type) {
                case 'zombie':
                    this.hp = 2 + Math.floor(wave/5); 
                    this.speed = (0.5 + Math.random() * 0.5) * 0.8; 
                    this.radius = 12;
                    this.color = '#448844'; 
                    break;
                case 'tank':
                    this.hp = 25 + (wave * 2);
                    this.speed = 1.1; 
                    this.radius = 24;
                    this.color = '#884400';
                    break;
                case 'flanker':
                    this.hp = 4 + wave;
                    this.speed = (2.2) * 0.8; 
                    this.radius = 12;
                    this.color = '#aa33ff';
                    this.flankDir = Math.random() < 0.5 ? 1 : -1;
                    break;
                case 'blind':
                    this.hp = 8 + wave;
                    this.speed = (3.0) * 0.8; 
                    this.radius = 14;
                    this.color = '#888888';
                    break;
            }
        }

        update(dt) {
            this.vx *= (1 - (0.2 * dt)); 
            this.vy *= (1 - (0.2 * dt));

            let dx = player.x - this.x;
            let dy = player.y - this.y;
            let dist = Math.sqrt(dx*dx + dy*dy);
            let targetAngle = Math.atan2(dy, dx);
            
            let moveX = 0, moveY = 0;

            if (dist > 0) {
                let ndx = dx / dist;
                let ndy = dy / dist;

                if (this.type === 'tank') {
                    let delta = normalizeAngle(targetAngle - this.facing);
                    const turnSpeed = 0.005 * dt; 
                    if (Math.abs(delta) < turnSpeed) this.facing = targetAngle;
                    else this.facing += Math.sign(delta) * turnSpeed;
                    moveX = Math.cos(this.facing);
                    moveY = Math.sin(this.facing);
                }
                else if (this.type === 'flanker') {
                    moveX = ndx + (-ndy * 0.8 * this.flankDir);
                    moveY = ndy + (ndx * 0.8 * this.flankDir);
                    this.facing = Math.atan2(moveY, moveX);
                } 
                else if (this.type === 'blind') {
                    if (noisePos) {
                        let nDx = noisePos.x - this.x;
                        let nDy = noisePos.y - this.y;
                        let nDist = Math.sqrt(nDx*nDx + nDy*nDy);
                        if (nDist > 5) {
                            moveX = nDx / nDist;
                            moveY = nDy / nDist;
                            this.facing = Math.atan2(moveY, moveX);
                        } else {
                            moveX = 0; moveY = 0;
                        }
                    } else {
                         moveX = (Math.random() - 0.5) * 0.2;
                         moveY = (Math.random() - 0.5) * 0.2;
                         this.facing += (Math.random()-0.5)*0.1 * dt;
                    }
                }
                else {
                    moveX = ndx;
                    moveY = ndy;
                    this.facing = targetAngle;
                }
                
                const moveLen = Math.sqrt(moveX*moveX + moveY*moveY);
                if (moveLen > 0 && this.type !== 'tank') {
                    moveX /= moveLen;
                    moveY /= moveLen;
                }

                if (Math.abs(this.vx) < 1 && Math.abs(this.vy) < 1) {
                    this.x += moveX * this.speed * dt;
                    this.y += moveY * this.speed * dt;
                }
            }

            this.x += this.vx * dt;
            this.y += this.vy * dt;

            // Separation
            for (let other of enemies) {
                if (other === this) continue;
                const dx2 = this.x - other.x;
                const dy2 = this.y - other.y;
                const dist2 = Math.sqrt(dx2*dx2 + dy2*dy2);
                const minSpace = this.radius + other.radius;
                if (dist2 < minSpace) {
                    const force = 0.5 * dt; 
                    const angle = Math.atan2(dy2, dx2);
                    this.x += Math.cos(angle) * force;
                    this.y += Math.sin(angle) * force;
                }
            }
        }

        draw(ctx) {
            ctx.save();
            ctx.translate(this.x, this.y);
            ctx.rotate(this.facing);

            ctx.fillStyle = this.color;
            ctx.beginPath();
            if (this.type === 'tank') {
                ctx.fillRect(-this.radius, -this.radius, this.radius*2, this.radius*2);
                ctx.fillStyle = '#663300';
                ctx.fillRect(0, -5, this.radius + 5, 10);
                // Weak Point
                ctx.fillStyle = '#ff9900';
                ctx.shadowBlur = 10;
                ctx.shadowColor = '#ff5500';
                ctx.fillRect(-this.radius, -8, 6, 16);
                ctx.shadowBlur = 0;
            } else {
                ctx.arc(0, 0, this.radius, 0, Math.PI*2);
                ctx.fill();
            }
            
            // Eyes
            if (this.type !== 'blind' && this.type !== 'tank') {
                ctx.fillStyle = '#ffff00';
                ctx.beginPath();
                ctx.arc(6, 4, 3, 0, Math.PI*2); 
                ctx.arc(6, -4, 3, 0, Math.PI*2); 
                ctx.fill();
            } else if (this.type === 'blind') {
                ctx.strokeStyle = '#333';
                ctx.beginPath();
                ctx.arc(0,0, this.radius-4, 0, Math.PI*2);
                ctx.stroke();
            }
            ctx.restore();
        }
    }

    class Particle {
        constructor(x, y, color, speed, friction = 0.9) {
            this.x = x; this.y = y;
            const angle = Math.random() * Math.PI * 2;
            const vel = Math.random() * speed;
            this.vx = Math.cos(angle) * vel;
            this.vy = Math.sin(angle) * vel;
            this.life = 1.0;
            this.decay = 0.02 + Math.random() * 0.03;
            this.color = color;
            this.friction = friction;
        }
        update(dt) {
            this.x += this.vx * dt;
            this.y += this.vy * dt;
            this.vx *= (1 - ((1-this.friction) * dt)); 
            this.vy *= (1 - ((1-this.friction) * dt));
            this.life -= this.decay * dt;
        }
        draw(ctx) {
            ctx.globalAlpha = this.life;
            ctx.fillStyle = this.color;
            ctx.fillRect(this.x, this.y, 4, 4);
            ctx.globalAlpha = 1.0;
        }
    }

    // -- UPDATE LOOP --
    function update(realTime) {
        if (!isGameRunning) return;
        if (hitStop > 0) { hitStop--; return; }

        let dt = 1.0;
        if (keys.shift && player.focus > 0) {
            dt = SLOW_MO_FACTOR;
            player.focus -= FOCUS_DRAIN;
            if (player.focus < 0) player.focus = 0;
        } else {
            if (player.focus < player.maxFocus) {
                player.focus += FOCUS_REGEN;
            }
        }
        
        document.getElementById('focus-bar').style.width = player.focus + '%';
        gameTime += 16.6 * dt; // Advance Game Time

        // Camera Follow
        const camTargetX = player.x - width / 2;
        const camTargetY = player.y - height / 2;
        camera.x += (camTargetX - camera.x) * 0.1;
        camera.y += (camTargetY - camera.y) * 0.1;
        camera.x = Math.max(0, Math.min(WORLD_SIZE - width, camera.x));
        camera.y = Math.max(0, Math.min(WORLD_SIZE - height, camera.y));

        // Arena Growth
        if (wave >= 10 && arena.targetW < WORLD_SIZE - 200) {
            arena.targetW = WORLD_SIZE - 200;
            arena.targetH = WORLD_SIZE - 200;
        }
        if (arena.w < arena.targetW) {
            arena.w += 2 * dt;
            arena.h += 2 * dt;
            arena.x = (WORLD_SIZE - arena.w) / 2;
            arena.y = (WORLD_SIZE - arena.h) / 2;
        }

        const wp = WEAPONS[player.weapon];

        // 1. DASH
        let isDashing = (gameTime - lastDashTime < DASH_DURATION);
        const dashP = Math.min(1, (gameTime - (lastDashTime + DASH_DURATION)) / DASH_COOLDOWN);
        document.getElementById('dash-bar').style.width = (dashP * 100) + '%';
        
        if (keys.space && !isDashing && dashP >= 1) {
            lastDashTime = gameTime;
            isDashing = true;
            for(let i=0; i<10; i++) particles.push(new Particle(player.x, player.y, '#ffffff', 5));
            Audio.dash();
        }

        // 2. Movement
        let dx = 0; let dy = 0;
        if (keys.w) dy = -1;
        if (keys.s) dy = 1;
        if (keys.a) dx = -1;
        if (keys.d) dx = 1;
        
        if (dx !== 0 || dy !== 0) {
            const len = Math.sqrt(dx*dx + dy*dy);
            dx /= len; dy /= len;
        }

        player.vx *= (1 - (0.2 * dt));
        player.vy *= (1 - (0.2 * dt));

        const currentSpeed = isDashing ? DASH_SPEED : PLAYER_SPEED;
        player.x += (dx * currentSpeed * dt) + (player.vx * dt);
        player.y += (dy * currentSpeed * dt) + (player.vy * dt);
        
        if (isDashing && Math.random() < 0.5) {
             particles.push(new Particle(player.x, player.y, '#44ff44', 0));
        }

        player.x = Math.max(arena.x + 10, Math.min(arena.x + arena.w - 10, player.x));
        player.y = Math.max(arena.y + 10, Math.min(arena.y + arena.h - 10, player.y));

        const mouseWorldX = mouse.x + camera.x;
        const mouseWorldY = mouse.y + camera.y;
        player.angle = Math.atan2(mouseWorldY - player.y, mouseWorldX - player.x);

        // 3. Shooting
        if (mouse.left && gameTime - lastShotTime > wp.rate) {
            if (player.ammo > 0) {
                const mx = player.x + Math.cos(player.angle) * 20;
                const my = player.y + Math.sin(player.angle) * 20;
                
                for(let i=0; i<wp.count; i++) {
                    const spread = (Math.random() - 0.5) * wp.spread;
                    bullets.push(new Bullet(mx, my, player.angle + spread, wp.speed, wp.color, wp.damage, wp.explosive, wp.pierce));
                }
                
                player.vx -= Math.cos(player.angle) * wp.recoil;
                player.vy -= Math.sin(player.angle) * wp.recoil;
                shakeX = Math.cos(player.angle + Math.PI) * wp.recoil;
                shakeY = Math.sin(player.angle + Math.PI) * wp.recoil;
                
                noisePos = { x: player.x, y: player.y };
                lastShotTime = gameTime;
                particles.push(new Particle(player.x, player.y, '#aa8800', 3));
                
                if(player.weapon === 'shotgun') Audio.shotgun();
                else if (player.weapon === 'rocket') Audio.rocket();
                else Audio.shoot();

                if (player.ammo !== Infinity) {
                    player.ammo--;
                    if (player.ammo <= 0) setWeapon('pistol');
                    updateUI();
                }
            } else {
                if (player.weapon !== 'pistol') setWeapon('pistol');
            }
        }

        // 4. Grenade
        const cdPercent = Math.min(1, (gameTime - lastGrenadeTime) / GRENADE_COOLDOWN);
        document.getElementById('grenade-bar').style.width = (cdPercent * 100) + '%';
        document.getElementById('grenade-bar').style.backgroundColor = cdPercent >= 1 ? '#3388ff' : '#555';

        if (mouse.right && cdPercent >= 1) {
             grenades.push(new Grenade(player.x, player.y, player.angle));
             lastGrenadeTime = gameTime;
             player.vx -= Math.cos(player.angle) * 15; 
             player.vy -= Math.sin(player.angle) * 15;
             noisePos = { x: player.x, y: player.y };
             Audio.rocket();
        }

        // 5. Update Bullets
        for (let i = bullets.length - 1; i >= 0; i--) {
            bullets[i].update(dt);
            let b = bullets[i];
            if (b.life <= 0 || b.x < arena.x || b.x > arena.x + arena.w || b.y < arena.y || b.y > arena.y + arena.h) {
                if (b.explosive) createExplosion(b.x, b.y);
                bullets.splice(i, 1);
            }
        }
        for (let i = grenades.length - 1; i >= 0; i--) {
            let g = grenades[i];
            g.update(dt);
            let explode = false;
            for (let e of enemies) {
                if (Math.hypot(g.x - e.x, g.y - e.y) < e.radius + 5) explode = true;
            }
            if (g.life <= 0) explode = true;
            if (explode) {
                createExplosion(g.x, g.y);
                grenades.splice(i, 1);
            }
        }

        // 6. Enemies
        if (gameTime - lastSpawnTime > Math.max(150, SPAWN_RATE - wave * 25)) {
            if (wave === 5 && Math.random() < 0.2) {
                 for(let k=0; k<3; k++) enemies.push(new Enemy('flanker'));
            } else {
                 enemies.push(new Enemy());
            }
            lastSpawnTime = gameTime;
        }

        // BUG FIX: Collision Logic crash caused by modifying array during loop.
        // Fixed by marking as dead instead of splicing inside inner loops.
        for (let i = enemies.length - 1; i >= 0; i--) {
            let e = enemies[i];
            
            // Clean up dead enemies
            if (e.dead) {
                enemies.splice(i, 1);
                continue;
            }

            e.update(dt);
            
            for (let j = bullets.length - 1; j >= 0; j--) {
                let b = bullets[j];
                if (Math.abs(e.x - b.x) > 40 || Math.abs(e.y - b.y) > 40) continue; 

                if (b.hitList && b.hitList.includes(e)) continue;

                const dist = Math.hypot(e.x - b.x, e.y - b.y);
                if (dist < e.radius + 10) {
                    let damageCalc = b.damage;
                    // Crit check
                    if (e.type === 'tank') {
                         let diff = Math.abs(normalizeAngle(b.angle - e.facing));
                         if (diff < Math.PI / 3) {
                             damageCalc *= 5;
                             Audio.crit();
                             for(let k=0; k<5; k++) particles.push(new Particle(e.x, e.y, '#ffaa00', 8));
                         }
                    }
                    e.hp -= damageCalc;
                    
                    if (b.explosive) {
                        createExplosion(b.x, b.y);
                        bullets.splice(j, 1);
                    } else if (b.pierce) {
                        b.hitList.push(e);
                        for(let k=0; k<3; k++) particles.push(new Particle(e.x, e.y, e.color, 5));
                    } else {
                        e.vx += Math.cos(b.angle) * (e.type === 'tank' ? 2 : 8); 
                        e.vy += Math.sin(b.angle) * (e.type === 'tank' ? 2 : 8);
                        bullets.splice(j, 1);
                        for(let k=0; k<3; k++) particles.push(new Particle(e.x, e.y, e.color, 5));
                    }
                    
                    noisePos = { x: e.x, y: e.y };
                    Audio.hit();

                    if (e.hp <= 0 && !e.dead) {
                        e.dead = true;
                        killEnemy(e, b.angle);
                        // Don't splice here, let next iteration handle it safely
                        // or splice immediately since we are at index i and break
                        enemies.splice(i, 1);
                        hitStop = 2;
                        // Important: Must break inner loop because e is gone
                        break; 
                    }
                    // If explosive bullet killed e via createExplosion, e.dead is true.
                    if (e.dead) {
                         enemies.splice(i, 1);
                         break;
                    }
                }
            }
            
            // Player Collision (Check if e still exists)
            if (enemies[i] && !enemies[i].dead) {
                const pDist = Math.hypot(enemies[i].x - player.x, enemies[i].y - player.y);
                if (pDist < enemies[i].radius + 15) {
                    player.hp -= 10;
                    updateUI();
                    shakeX = (Math.random()-0.5) * 20;
                    shakeY = (Math.random()-0.5) * 20;
                    const angle = Math.atan2(player.y - enemies[i].y, player.x - enemies[i].x);
                    player.vx += Math.cos(angle) * 10;
                    player.vy += Math.sin(angle) * 10;
                    
                    // Kill enemy on impact
                    enemies[i].dead = true;
                    enemies.splice(i, 1); 
                    
                    for(let k=0; k<10; k++) particles.push(new Particle(player.x, player.y, '#ff0000', 8));
                    Audio.hit();
                    if (player.hp <= 0) endGame();
                }
            }
        }

        // 7. Pickups
        for (let i = pickups.length - 1; i >= 0; i--) {
            pickups[i].update(dt);
            if (pickups[i].life <= 0) {
                pickups.splice(i, 1);
                continue;
            }
            const dist = Math.hypot(player.x - pickups[i].x, player.y - pickups[i].y);
            if (dist < 20) {
                const p = pickups[i];
                if (p.type === 'medikit') {
                    player.hp = Math.min(player.maxHp, player.hp + 25);
                    updateUI();
                    Audio.pickup();
                    for(let k=0; k<10; k++) particles.push(new Particle(player.x, player.y, '#00ff00', 5));
                } else {
                    setWeapon(p.type);
                    for(let k=0; k<10; k++) particles.push(new Particle(player.x, player.y, '#ffff00', 5));
                }
                pickups.splice(i, 1);
            }
        }

        // 8. Physics & Debris
        // Cull excess particles if too many
        if (particles.length > MAX_PARTICLES) {
            particles.splice(0, particles.length - MAX_PARTICLES);
        }

        for (let i = particles.length - 1; i >= 0; i--) {
            particles[i].update(dt);
            if (particles[i].life <= 0) particles.splice(i, 1);
        }
        for (let i = debris.length - 1; i >= 0; i--) {
            debris[i].update(dt);
            if (debris[i].life <= 0) {
                chunkManager.drawDebris(debris[i].x, debris[i].y, debris[i].rotation, debris[i].color, debris[i].w, debris[i].h);
                debris.splice(i, 1);
            }
        }

        shakeX *= 0.8;
        shakeY *= 0.8;
    }

    function createExplosion(x, y) {
        shakeX = 20; shakeY = 20;
        Audio.explode();
        for(let i=0; i<30; i++) particles.push(new Particle(x, y, '#ffaa00', 10));
        
        const range = 150;
        // Optimization: Don't splice here. Just mark dead.
        for (let i = enemies.length - 1; i >= 0; i--) {
            let e = enemies[i];
            const dist = Math.hypot(e.x - x, e.y - y);
            if (dist < range) {
                const damage = (1 - (dist/range)) * 30; 
                e.hp -= damage;
                
                const angle = Math.atan2(e.y - y, e.x - x);
                const force = (1 - (dist/range)) * 30;
                e.vx += Math.cos(angle) * force;
                e.vy += Math.sin(angle) * force;
                
                if (e.hp <= 0 && !e.dead) {
                    e.dead = true;
                    killEnemy(e, angle);
                }
            }
        }
    }

    function killEnemy(e, angle) {
        score++;
        
        if (score % 25 === 0) {
            wave++;
            if (wave < 10) {
                arena.targetW = Math.min(WORLD_SIZE - 200, ARENA_START_SIZE + (wave * ARENA_GROWTH));
                arena.targetH = Math.min(WORLD_SIZE - 200, ARENA_START_SIZE + (wave * ARENA_GROWTH));
            }
            updateUI();
        }
        updateUI();

        if (e.type === 'tank') Audio.tankDeath();
        else Audio.squish();
        
        // LOOT SYSTEM
        let drop = false;
        let baseChance = player.weapon === 'pistol' ? 0.25 : 0.12;

        if (e.type === 'tank') drop = true; 
        else if (Math.random() < baseChance) drop = true;

        if (drop) { 
            let isWeapon = false;
            if (e.type === 'tank') isWeapon = Math.random() < 0.8;
            else {
                let weaponChance = player.weapon === 'pistol' ? 0.6 : 0.3;
                isWeapon = Math.random() < weaponChance;
            }

            if (isWeapon) {
                let choices = [];
                if (wave < 5) choices = ['smg', 'shotgun'];
                else if (wave < 10) choices = ['smg', 'shotgun', 'minigun', 'rocket'];
                else choices = ['minigun', 'rocket', 'railgun'];
                const pick = choices[Math.floor(Math.random() * choices.length)];
                pickups.push(new Pickup(e.x, e.y, pick));
            } else {
                pickups.push(new Pickup(e.x, e.y, 'medikit'));
            }

        } else if (Math.random() < 0.05) { 
             pickups.push(new Pickup(e.x, e.y, 'medikit'));
        }

        const gibCount = e.type === 'tank' ? 12 : 5;
        for(let i=0; i<gibCount; i++) {
            debris.push(new Debris(e.x, e.y, e.color));
        }
        
        // Initial blood splatter (immediate)
        chunkManager.drawDebris(e.x, e.y, angle, '#660000', 15, 5);
    }

    function endGame() {
        isGameRunning = false;
        document.getElementById('game-over').style.display = 'block';
        document.getElementById('final-score').innerText = score;
    }

    function draw() {
        ctx.fillStyle = '#050505';
        ctx.fillRect(0, 0, width, height);
        
        ctx.save();
        
        const camX = camera.x + shakeX;
        const camY = camera.y + shakeY;
        
        ctx.translate(-camX, -camY);

        // Render Chunks
        chunkManager.render(ctx, {x: camX, y: camY});

        ctx.strokeStyle = '#331111';
        ctx.lineWidth = 8;
        ctx.strokeRect(arena.x, arena.y, arena.w, arena.h);
        ctx.strokeStyle = '#ff3333';
        ctx.lineWidth = 2;
        ctx.globalAlpha = 0.5 + Math.sin(Date.now() / 200) * 0.2;
        ctx.strokeRect(arena.x, arena.y, arena.w, arena.h);
        ctx.globalAlpha = 1.0;

        pickups.forEach(p => p.draw(ctx));
        grenades.forEach(g => g.draw(ctx));
        bullets.forEach(b => b.draw(ctx));
        debris.forEach(d => d.draw(ctx)); 
        enemies.forEach(e => e.draw(ctx));

        // Player
        ctx.save();
        ctx.translate(player.x, player.y);
        ctx.rotate(player.angle);
        ctx.fillStyle = '#44ff44';
        ctx.shadowBlur = 10;
        ctx.shadowColor = '#00ff00';
        ctx.beginPath();
        ctx.arc(0, 0, 15, 0, Math.PI*2);
        ctx.fill();
        ctx.shadowBlur = 0;
        ctx.fillStyle = '#228822';
        ctx.fillRect(0, -5, 25, 10);
        ctx.restore();

        particles.forEach(p => p.draw(ctx));

        ctx.restore();
    }

    function loop(time) {
        update(time);
        draw();
        if (isGameRunning) requestAnimationFrame(loop);
    }
</script>
</body>
</html>
