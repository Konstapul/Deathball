<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Sector Zero - Phobia Tribute</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #050505;
            cursor: crosshair;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            user-select: none;
        }
        canvas { display: block; position: absolute; top: 0; left: 0; }
        
        #flash-overlay {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: #fff;
            opacity: 0;
            pointer-events: none;
            z-index: 100;
            transition: opacity 0.1s ease-out;
        }

        #warning-overlay {
            position: absolute;
            top: 15%; left: 0; width: 100%;
            text-align: center;
            pointer-events: none;
            z-index: 90;
            display: none;
        }
        #warning-text {
            font-size: 30px;
            font-weight: 700;
            color: #ff3333;
            text-shadow: 0 0 10px #ff0000;
            letter-spacing: 2px;
            background: rgba(0,0,0,0.5);
            padding: 10px;
            display: inline-block;
            border: 1px solid #ff3333;
            animation: blink 0.5s infinite;
        }
        @keyframes blink { 50% { opacity: 0; } }

        /* --- NEW HUD STYLES --- */
        #hud-top-left {
            position: absolute; top: 20px; left: 20px;
            display: flex; flex-direction: column; gap: 8px;
            width: 280px;
            pointer-events: none;
            z-index: 10;
        }

        .bar-wrapper {
            position: relative;
        }
        .bar-label {
            font-size: 10px; color: #888; text-transform: uppercase; letter-spacing: 1px;
            margin-bottom: 2px; font-weight: 700;
        }
        
        /* Health Bar */
        #health-container {
            width: 100%; height: 20px;
            background: rgba(10, 10, 10, 0.8);
            border: 1px solid #444;
            transform: skewX(-20deg);
            padding: 2px;
            box-shadow: 0 0 10px rgba(0,0,0,0.5);
        }
        #health-fill {
            height: 100%; width: 100%; 
            background: linear-gradient(90deg, #cc0000, #ff3333);
            box-shadow: 0 0 10px #ff0000;
            transition: width 0.1s;
        }

        /* Sub Bars (Dash/Focus) */
        .sub-bars {
            display: flex; gap: 10px;
            margin-top: 5px;
        }
        .sub-bar-group { flex: 1; }
        .sub-bar-container {
            width: 100%; height: 6px;
            background: rgba(10, 10, 10, 0.8);
            border: 1px solid #444;
            transform: skewX(-20deg);
            padding: 1px;
        }
        .sub-bar-fill { height: 100%; width: 100%; transition: width 0.1s; }
        #dash-fill { background: #fff; box-shadow: 0 0 5px #fff; }
        #focus-fill { background: #ffcc00; box-shadow: 0 0 5px #ffcc00; }

        /* Top Right Score */
        #hud-top-right {
            position: absolute; top: 20px; right: 20px;
            text-align: right;
            pointer-events: none;
            z-index: 10;
        }
        .score-val { font-size: 32px; font-weight: 900; color: #fff; text-shadow: 0 0 10px rgba(255,255,255,0.3); line-height: 1; }
        .score-label { font-size: 12px; color: #888; text-transform: uppercase; letter-spacing: 2px; margin-bottom: 5px; }
        .wave-val { font-size: 20px; color: #44ff44; font-weight: bold; margin-top: 5px; }

        /* Bottom HUD (Weapons) */
        #hud-bottom {
            position: absolute; bottom: 30px; left: 50%;
            transform: translateX(-50%);
            display: flex; align-items: flex-end; gap: 40px;
            pointer-events: none;
            z-index: 10;
        }

        .weapon-widget {
            display: flex; flex-direction: column; align-items: center;
            opacity: 0.9; transition: opacity 0.2s, transform 0.2s;
        }
        .weapon-widget.secondary { opacity: 0.6; transform: scale(0.85); }
        .weapon-widget.secondary.active { opacity: 1; transform: scale(1.0); }

        .w-name {
            font-size: 16px; font-weight: 800; color: #ffff00; text-transform: uppercase;
            letter-spacing: 1px; text-shadow: 0 0 5px rgba(255, 255, 0, 0.5);
            margin-bottom: 4px;
        }
        .w-row { display: flex; align-items: center; gap: 10px; }
        .w-bar-box {
            width: 180px; height: 10px;
            background: rgba(20, 20, 20, 0.8);
            border: 1px solid #555;
            transform: skewX(-20deg);
            padding: 2px;
            display: flex; justify-content: flex-start;
        }
        .w-bar-fill {
            height: 100%; width: 100%; background: #fff;
            box-shadow: 0 0 8px currentColor;
            transition: width 0.1s, background-color 0.2s;
        }
        .w-count {
            font-size: 28px; font-weight: 900; color: #fff;
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.3);
            min-width: 60px; text-align: left;
        }
        
        /* Secondary specific styles override */
        .weapon-widget.secondary .w-name { color: #44ff44; text-shadow: 0 0 5px rgba(68, 255, 68, 0.5); }
        .weapon-widget.secondary .w-bar-fill { background-color: #44ff44; }

        #dev-menu {
            display: none;
            position: absolute;
            top: 20px;
            right: 20px;
            width: 200px;
            background: rgba(0, 0, 0, 0.9);
            border: 2px solid #44ff44;
            padding: 10px;
            z-index: 100;
            font-family: monospace;
        }
        #dev-menu h3 {
            margin: 0 0 10px 0;
            color: #44ff44;
            text-align: center;
            border-bottom: 1px solid #333;
            padding-bottom: 5px;
        }
        .dev-btn {
            display: block;
            width: 100%;
            background: #222;
            color: #fff;
            border: 1px solid #444;
            padding: 5px;
            margin-bottom: 5px;
            cursor: pointer;
            text-align: left;
            font-size: 12px;
        }
        .dev-btn:hover { background: #444; }
        
        #game-over, #start-screen, #pause-screen {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            z-index: 20;
            background: rgba(0, 10, 0, 0.95);
            padding: 40px;
            border: 2px solid #44ff44;
            color: #44ff44;
            box-shadow: 0 0 50px rgba(0, 255, 0, 0.2);
        }
        #game-over { display: none; }
        #pause-screen { display: none; z-index: 95; }
        
        button {
            background: #003300;
            border: 1px solid #44ff44;
            color: #44ff44;
            padding: 15px 30px;
            font-size: 20px;
            cursor: pointer;
            text-transform: uppercase;
            margin-top: 20px;
            font-family: inherit;
        }
        button:hover { background: #44ff44; color: #000; }
        .controls-hint { color: #888; font-size: 14px; margin-top: 10px; }
    </style>
</head>
<body>

    <div id="flash-overlay"></div>
    <div id="warning-overlay"><div id="warning-text">⚠ NUCLEAR DETECTED ⚠</div></div>
    <canvas id="gameCanvas"></canvas>

    <!-- DEV MENU -->
    <div id="dev-menu">
        <h3>DEV CONSOLE</h3>
        <button class="dev-btn" onclick="devBossFight()">JUMP TO BOSS (W20)</button>
        <button class="dev-btn" onclick="devMaxAmmo()">MAX AMMO</button>
        <button class="dev-btn" id="god-mode-btn" onclick="devToggleGodMode()">GOD MODE: OFF</button>
        <button class="dev-btn" id="super-dmg-btn" onclick="devToggleSuperDamage()">SUPER DAMAGE: OFF</button>
        <button class="dev-btn" onclick="devNuke()">SPAWN NUKE</button>
        <div style="font-size:10px; color:#666; margin-top:5px; text-align:center;">Press L to Toggle</div>
    </div>

    <!-- NEW HUD STRUCTURE -->
    <div id="hud-top-left">
        <div class="bar-wrapper">
            <div class="bar-label">Health</div>
            <div id="health-container"><div id="health-fill"></div></div>
        </div>
        <div class="sub-bars">
            <div class="sub-bar-group">
                <div class="bar-label">Dash</div>
                <div class="sub-bar-container"><div class="sub-bar-fill" id="dash-fill"></div></div>
            </div>
            <div class="sub-bar-group">
                <div class="bar-label">Focus</div>
                <div class="sub-bar-container"><div class="sub-bar-fill" id="focus-fill"></div></div>
            </div>
        </div>
    </div>

    <div id="hud-top-right">
        <div class="score-label">Confirmed Kills</div>
        <div class="score-val" id="score-display">0</div>
        <div class="score-label" style="font-size: 10px; margin-top: 5px;">High Score: <span id="highscore-display">0</span></div>
        <div class="wave-val" id="wave-display">WAVE 1</div>
    </div>

    <div id="hud-bottom">
        <!-- Primary Weapon -->
        <div class="weapon-widget" id="primary-widget">
            <div class="w-name" id="p-name">PISTOL</div>
            <div class="w-row">
                <div class="w-bar-box"><div class="w-bar-fill" id="p-bar"></div></div>
                <div class="w-count" id="p-count">∞</div>
            </div>
        </div>
        
        <!-- Secondary Weapon -->
        <div class="weapon-widget secondary" id="secondary-widget" style="display:none;">
            <div class="w-name" id="s-name">GRENADE</div>
            <div class="w-row">
                <div class="w-bar-box" style="width: 120px;"><div class="w-bar-fill" id="s-bar"></div></div>
                <div class="w-count" id="s-count" style="font-size: 24px;">0</div>
            </div>
        </div>
    </div>

    <div id="start-screen">
        <h1 style="font-size: 40px; margin: 0 0 10px 0;">SECTOR ZERO</h1>
        <p>SURVIVE THE HORDE</p>
        <div class="controls-hint">
            <p>WASD to Move | Mouse to Aim</p>
            <p>SHIFT to Activate Bullet Time</p>
            <p>SPACE to Dash | R-CLICK for Secondary | P to Pause</p>
            <p>Boss Warning: Wave 20</p>
        </div>
        <button onclick="startGame()">INITIATE</button>
    </div>

    <div id="pause-screen">
        <h1 style="font-size: 40px; margin: 0 0 10px 0;">PAUSED</h1>
        <p>TACTICAL SUSPENSION</p>
        <button onclick="togglePause()">RESUME</button>
    </div>

    <div id="game-over">
        <h1 style="font-size: 40px; margin: 0 0 10px 0;">M.I.A.</h1>
        <p>SECTOR LOST</p>
        <p>CONFIRMED KILLS: <span id="final-kills">0</span></p>
        <p>TOTAL SCORE: <span id="final-points" style="color: #ffff00; font-weight:bold;">0</span></p>
        <button onclick="restartGame()">REDEPLOY</button>
    </div>

<script>
    const Audio = (function() {
        let ctx = null;
        let enabled = false;
        let noiseBuffer = null;

        function init() {
            if (!ctx) {
                ctx = new (window.AudioContext || window.webkitAudioContext)();
                enabled = true;
                noiseBuffer = createNoiseBuffer();
            }
            if (ctx.state === 'suspended') ctx.resume();
        }

        function createNoiseBuffer() {
            if (!ctx) return null;
            const duration = 2.0; 
            const bufferSize = ctx.sampleRate * duration;
            const buffer = ctx.createBuffer(1, bufferSize, ctx.sampleRate);
            const data = buffer.getChannelData(0);
            for (let i = 0; i < bufferSize; i++) {
                data[i] = Math.random() * 2 - 1;
            }
            return buffer;
        }

        function playTone(freq, type, duration, vol = 0.1, ramp = true) {
            if (!enabled) return;
            const osc = ctx.createOscillator();
            const gain = ctx.createGain();
            osc.type = type;
            osc.frequency.setValueAtTime(freq, ctx.currentTime);
            if(ramp) osc.frequency.exponentialRampToValueAtTime(freq * 0.1, ctx.currentTime + duration);
            gain.gain.setValueAtTime(vol, ctx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + duration);
            osc.connect(gain);
            gain.connect(ctx.destination);
            osc.start();
            osc.stop(ctx.currentTime + duration);
        }

        function playNoise(duration, vol = 0.2) {
            if (!enabled || !noiseBuffer) return;
            const noise = ctx.createBufferSource();
            noise.buffer = noiseBuffer;
            const gain = ctx.createGain();
            gain.gain.setValueAtTime(vol, ctx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + duration);
            noise.connect(gain);
            gain.connect(ctx.destination);
            noise.start();
            noise.stop(ctx.currentTime + duration);
        }

        return {
            init,
            shoot: () => playTone(300 + Math.random()*100, 'square', 0.08, 0.03), 
            shotgun: () => { playTone(150, 'sawtooth', 0.2, 0.08); playNoise(0.2, 0.08); },
            rocket: () => { playTone(100, 'triangle', 0.5, 0.1); playNoise(0.5, 0.05); },
            explode: () => playNoise(0.5, 0.3),
            mineExplode: () => { playTone(60, 'square', 0.5, 0.4); playNoise(0.8, 0.4); }, // Deeper boom
            hit: () => playTone(100, 'sawtooth', 0.1, 0.05),
            playerDamage: () => { 
                playNoise(0.15, 0.6); 
                playTone(400, 'sawtooth', 0.1, 0.4); 
            }, 
            crit: () => playTone(800, 'square', 0.1, 0.1), 
            dash: () => playTone(600, 'sine', 0.2, 0.05),
            pickup: () => playTone(800, 'sine', 0.2, 0.1, false),
            squish: () => { playNoise(0.05, 0.1); playTone(60, 'sine', 0.1, 0.15); }, 
            tankDeath: () => { playNoise(0.4, 0.3); playTone(50, 'square', 0.5, 0.2); },
            spawnTank: () => playTone(40, 'sawtooth', 1.5, 0.06, false), 
            spawnFlanker: () => playTone(600, 'triangle', 0.3, 0.05, true),
            spawnBlind: () => playNoise(0.5, 0.05),
            spawnBoss: () => { playTone(30, 'sawtooth', 3.0, 0.3, false); playNoise(3.0, 0.2); },
            nukeSpawn: () => {
                 playTone(100, 'sawtooth', 1.0, 0.2, false); 
                 setTimeout(() => playTone(150, 'sawtooth', 1.0, 0.2, false), 500);
            },
            nukePing: (vol) => playTone(1000, 'sine', 0.1, vol),
            nukeBlast: () => { playNoise(2.0, 0.5); playTone(50, 'square', 1.0, 0.5); },
            slowMoStart: () => playTone(100, 'sine', 0.3, 0.1, false),
            slowMoEnd: () => playTone(200, 'sine', 0.2, 0.1),
            bossCharge: () => { playTone(80, 'sawtooth', 1.0, 0.2, false); playNoise(0.5, 0.2); },
            bossImpact: () => { playNoise(0.5, 0.5); playTone(40, 'square', 0.5, 0.5); },
            bossZap: () => { playTone(1500, 'sawtooth', 0.1, 0.3); playTone(500, 'square', 0.1, 0.3); },
            bossClash: () => { playNoise(1.0, 1.0); playTone(50, 'square', 1.0, 1.0); },
            weakPoint: () => { playTone(1200, 'triangle', 0.1, 0.2); playTone(1500, 'sine', 0.1, 0.2, false); },
            minigunWindup: () => {
                if (!enabled) return;
                const osc = ctx.createOscillator();
                const gain = ctx.createGain();
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(50, ctx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(200, ctx.currentTime + 0.5);
                gain.gain.setValueAtTime(0.1, ctx.currentTime);
                gain.gain.linearRampToValueAtTime(0, ctx.currentTime + 0.5);
                osc.connect(gain);
                gain.connect(ctx.destination);
                osc.start();
                osc.stop(ctx.currentTime + 0.5);
            },
            minigunSpin: () => playTone(80, 'square', 0.1, 0.05),
            mineSet: () => playTone(1200, 'sine', 0.1, 0.1),
            turretFire: () => playTone(800, 'square', 0.05, 0.05)
        };
    })();

    class ChunkManager {
        constructor(worldSize, chunkSize) {
            this.chunkSize = chunkSize;
            this.cols = Math.ceil(worldSize / chunkSize);
            this.rows = Math.ceil(worldSize / chunkSize);
            this.chunks = [];
            for(let x = 0; x < this.cols; x++) {
                this.chunks[x] = [];
                for(let y = 0; y < this.rows; y++) {
                    const c = document.createElement('canvas');
                    c.width = chunkSize;
                    c.height = chunkSize;
                    this.chunks[x][y] = { canvas: c, ctx: c.getContext('2d') };
                }
            }
            this.reset();
        }

        reset() {
            for(let x = 0; x < this.cols; x++) {
                for(let y = 0; y < this.rows; y++) {
                    const ctx = this.chunks[x][y].ctx;
                    ctx.clearRect(0, 0, this.chunkSize, this.chunkSize);
                }
            }
        }

        drawDebris(x, y, rotation, color, w, h) {
            const cx = Math.floor(x / this.chunkSize);
            const cy = Math.floor(y / this.chunkSize);
            if(cx >= 0 && cx < this.cols && cy >= 0 && cy < this.rows) {
                const chunk = this.chunks[cx][cy];
                const localX = x - (cx * this.chunkSize);
                const localY = y - (cy * this.chunkSize);
                chunk.ctx.save();
                chunk.ctx.translate(localX, localY);
                chunk.ctx.rotate(rotation);
                chunk.ctx.fillStyle = color;
                chunk.ctx.globalAlpha = 0.5;
                chunk.ctx.fillRect(-w/2, -h/2, w, h);
                chunk.ctx.restore();
            }
        }

        render(ctx, camera) {
            const startCol = Math.floor(camera.x / this.chunkSize);
            const endCol = Math.floor((camera.x + ctx.canvas.width) / this.chunkSize);
            const startRow = Math.floor(camera.y / this.chunkSize);
            const endRow = Math.floor((camera.y + ctx.canvas.height) / this.chunkSize);

            for(let x = startCol; x <= endCol; x++) {
                for(let y = startRow; y <= endRow; y++) {
                    if(x >= 0 && x < this.cols && y >= 0 && y < this.rows) {
                        const drawX = x * this.chunkSize;
                        const drawY = y * this.chunkSize;
                        ctx.drawImage(this.chunks[x][y].canvas, drawX, drawY);
                    }
                }
            }
        }
    }

    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    
    const WORLD_SIZE = 3000;
    const CHUNK_SIZE = 1000;
    const chunkManager = new ChunkManager(WORLD_SIZE, CHUNK_SIZE);

    const SPAWN_RATE = 1100; 
    const GRENADE_COOLDOWN = 3000; 
    const DASH_COOLDOWN = 3750; 
    const DASH_DURATION = 150;
    const DASH_IMPULSE = 12; 
    const MAX_PARTICLES = 200; 
    
    // PHYSICS CONSTANTS
    const PLAYER_ACCEL = 0.45; 
    const PLAYER_FRICTION = 0.87; 
    
    const ARENA_START_SIZE = 800; 
    const ARENA_GROWTH = 150;     
    const KILLS_PER_WAVE = 35; 

    let timeScale = 1.0;
    let gameTime = 0; 
    const SLOW_MO_FACTOR = 0.2;
    const FOCUS_DRAIN = 0.3; 
    const FOCUS_REGEN = 0.08; 
    
    let godMode = false;
    let superDamage = false;
    let isPaused = false;

    // RECOIL TUNING: Shotgun (4.0), SMG (0.3), Minigun (0.8)
    const WEAPONS = {
        pistol: { name: 'PISTOL', tier: 1, rate: 400, speed: 12, damage: 2, spread: 0.02, count: 1, color: '#ffaa00', recoil: 0.5, ammo: Infinity, maxCarry: Infinity },
        smg:    { name: 'SMG',    tier: 1, rate: 110, speed: 13, damage: 1.8, spread: 0.15, count: 1, color: '#ffffaa', recoil: 0.3, ammo: 120, maxCarry: 360 }, 
        shotgun:{ name: 'SHOTGUN',tier: 1, rate: 1500, speed: 11, damage: 2, spread: 0.35, count: 7, color: '#ffff00', recoil: 4.0, ammo: 24, maxCarry: 72 }, 
        minigun:{ name: 'MINIGUN',tier: 2, rate: 55,  speed: 14, damage: 2.7, spread: 0.15, count: 1, color: '#00ffff', recoil: 0.8, ammo: 300, maxCarry: 900 }, 
        rocket: { name: 'ROCKET', tier: 2, rate: 1200, speed: 8,  damage: 20, spread: 0,    count: 1, color: '#ff4444', recoil: 6.0, ammo: 12, maxCarry: 36, explosive: true },
        railgun:{ name: 'RAILGUN',tier: 3, rate: 1500, speed: 30, damage: 50, spread: 0,    count: 1, color: '#ff00ff', recoil: 0, ammo: 12, maxCarry: 36, pierce: true } 
    };

    // SPARE AMMO ADDED (2x pickup amount)
    const SECONDARIES = {
        mine: { name: 'MINE', ammo: 5, maxAmmo: 10, color: '#ff0000' },
        turret: { name: 'SENTRY', ammo: 2, maxAmmo: 4, color: '#44ff44' },
        cluster: { name: 'CLUSTER', ammo: 8, maxAmmo: 16, color: '#ffaa00' }
    };

    let width, height;
    let camera = { x: 0, y: 0 };
    
    // Player state includes secondary weapon info
    let player = { 
        x: 0, y: 0, vx: 0, vy: 0, 
        hp: 100, maxHp: 100, angle: 0, 
        weapon: 'pistol', ammo: Infinity, 
        secondaryWeapon: null, secondaryAmmo: 0,
        focus: 100, maxFocus: 100, focusActive: false, 
        minigunWindup: 0, minigunSoundTimer: 0 
    };

    let bullets = [];
    let grenades = [];
    let mines = [];
    let turrets = [];
    let enemies = [];
    let particles = []; 
    let debris = [];    
    let pickups = [];
    let corpses = []; 
    
    let keys = { w: false, a: false, s: false, d: false, space: false, shift: false };
    let mouse = { x: 0, y: 0, left: false, right: false };
    
    let lastShotTime = 0;
    let lastGrenadeTime = 0;
    let lastDashTime = 0;
    let lastSpawnTime = 0;
    let lastNukeSpawnTime = -99999;
    
    let score = 0; 
    let points = 0; 
    let highScore = 0; 
    let wave = 1;
    let isGameRunning = false;
    let shakeX = 0, shakeY = 0;
    let hitStop = 0;
    let noisePos = null; 
    let nukeTimer = 0; 
    
    let arena = { x: 0, y: 0, w: 0, h: 0, targetW: 0, targetH: 0 };

    function resize() {
        width = window.innerWidth;
        height = window.innerHeight;
        canvas.width = width;
        canvas.height = height;
    }
    window.addEventListener('resize', resize);
    window.addEventListener('contextmenu', e => e.preventDefault());

    function init() {
        resize();
        chunkManager.reset();
        
        player.x = WORLD_SIZE/2;
        player.y = WORLD_SIZE/2;
        player.vx = 0;
        player.vy = 0;
        player.hp = 100;
        player.focus = 100;
        player.focusActive = false;
        player.weapon = 'pistol';
        player.ammo = Infinity;
        player.secondaryWeapon = null;
        player.secondaryAmmo = 0;

        score = 0;
        points = 0;
        wave = 1;
        gameTime = 0;
        isPaused = false;
        
        arena.w = ARENA_START_SIZE;
        arena.h = ARENA_START_SIZE;
        arena.targetW = ARENA_START_SIZE;
        arena.targetH = ARENA_START_SIZE;
        arena.x = (WORLD_SIZE - arena.w) / 2;
        arena.y = (WORLD_SIZE - arena.h) / 2;
        
        bullets = [];
        grenades = [];
        mines = [];
        turrets = [];
        enemies = [];
        particles = [];
        debris = [];
        pickups = [];
        corpses = [];
        
        isGameRunning = true;
        noisePos = null;
        
        lastGrenadeTime = -GRENADE_COOLDOWN; 
        lastDashTime = -DASH_COOLDOWN;
        lastShotTime = 0; 
        lastSpawnTime = 0;
        lastNukeSpawnTime = -99999;
        
        updateUI();
        document.getElementById('start-screen').style.display = 'none';
        document.getElementById('game-over').style.display = 'none';
        document.getElementById('pause-screen').style.display = 'none';
        document.getElementById('dev-menu').style.display = 'none';
        document.getElementById('warning-overlay').style.display = 'none';
        
        Audio.init();
        requestAnimationFrame(loop);
    }

    function startGame() { init(); }
    function restartGame() { init(); }

    function togglePause() {
        if (!isGameRunning) return;
        isPaused = !isPaused;
        document.getElementById('pause-screen').style.display = isPaused ? 'block' : 'none';
    }

    function updateUI() {
        document.getElementById('health-fill').style.width = Math.max(0, player.hp) + '%';
        document.getElementById('score-display').innerText = score;
        document.getElementById('highscore-display').innerText = highScore;
        document.getElementById('wave-display').innerText = 'WAVE ' + wave;
        
        const weapon = WEAPONS[player.weapon];
        document.getElementById('p-name').innerText = weapon.name;
        document.getElementById('p-name').style.color = weapon.color;
        
        const pFill = document.getElementById('p-bar');
        const pCount = document.getElementById('p-count');
        
        if (player.ammo === Infinity) {
            pFill.style.width = '100%';
            pFill.style.backgroundColor = weapon.color;
            pCount.innerText = '∞';
        } else {
            const pct = Math.min(100, (player.ammo / weapon.maxCarry) * 100);
            pFill.style.width = pct + '%';
            pFill.style.backgroundColor = weapon.color;
            pCount.innerText = player.ammo;
            if (player.ammo <= weapon.ammo * 0.2) pFill.style.backgroundColor = '#ff0000';
        }

        // Secondary UI
        const sWidget = document.getElementById('secondary-widget');
        if (player.secondaryWeapon && player.secondaryAmmo > 0) {
            sWidget.style.display = 'flex';
            const sw = SECONDARIES[player.secondaryWeapon];
            document.getElementById('s-name').innerText = sw.name;
            document.getElementById('s-name').style.color = sw.color;
            document.getElementById('s-count').innerText = player.secondaryAmmo;
            
            // Cooldown visual on bar
            const cdPercent = Math.min(1, (gameTime - lastGrenadeTime) / GRENADE_COOLDOWN);
            const sBar = document.getElementById('s-bar');
            sBar.style.width = (cdPercent * 100) + '%';
            sBar.style.backgroundColor = cdPercent >= 1 ? sw.color : '#555';
            
            if (cdPercent >= 1) sWidget.classList.add('active'); else sWidget.classList.remove('active');
        } else {
            sWidget.style.display = 'none';
            // If no secondary, show grenade bar logic implicitly or just hide?
            // User requested secondary UI match primary. If no secondary picked up, maybe hide it.
        }
    }

    function spawnNukePickup() {
        lastNukeSpawnTime = gameTime;
        Audio.nukeSpawn();
        const warning = document.getElementById('warning-overlay');
        warning.style.display = 'block';
        setTimeout(() => { warning.style.display = 'none'; }, 3000);
        pickups.push(new Pickup(0, 0, 'nuke'));
    }

    function detonateNuke(nx, ny) {
        const flash = document.getElementById('flash-overlay');
        flash.style.transition = 'none';
        flash.style.opacity = 1;
        setTimeout(() => {
            flash.style.transition = 'opacity 1.0s ease-out';
            flash.style.opacity = 0;
        }, 50);

        shakeX = 50; shakeY = 50;
        Audio.nukeBlast();

        for(let k=0; k<50; k++) {
            const ang = (Math.PI*2/50)*k;
            const spd = 20;
            particles.push(new Particle(nx, ny, '#fff', spd));
        }

        const blastRadius = 800;

        for(let i = enemies.length - 1; i >= 0; i--) {
            const e = enemies[i];
            const dist = Math.hypot(e.x - nx, e.y - ny);
            
            if (dist < blastRadius) {
                if (e.type === 'boss') {
                    e.hp -= (e.maxHp / 7); 
                    for(let k=0; k<5; k++) particles.push(new Particle(e.x, e.y, '#ff0000', 5));
                    if (e.hp <= 0 && !e.dying) { 
                        e.dying = true; 
                        e.dyingTimer = 0;
                    }
                } else if (!e.dead) {
                    e.dead = true;
                    killEnemy(e, 0, true);
                    enemies.splice(i, 1);
                }
            }
        }
    }

    function toggleDevMenu() {
        const menu = document.getElementById('dev-menu');
        menu.style.display = menu.style.display === 'none' ? 'block' : 'none';
    }

    function devBossFight() {
        if (!isGameRunning) init();
        wave = 20; score = 500; 
        arena.targetW = WORLD_SIZE - 200; arena.targetH = WORLD_SIZE - 200;
        arena.w = arena.targetW; arena.h = arena.targetH;
        arena.x = (WORLD_SIZE - arena.w) / 2; arena.y = (WORLD_SIZE - arena.h) / 2;
        setWeapon('railgun'); player.ammo = WEAPONS.railgun.maxCarry;
        enemies = []; enemies.push(new Enemy('boss')); enemies.push(new Enemy('boss'));
        updateUI(); toggleDevMenu();
    }

    function devMaxAmmo() {
        if(player.weapon !== 'pistol') { player.ammo = WEAPONS[player.weapon].maxCarry; updateUI(); }
        toggleDevMenu();
    }

    function devToggleGodMode() {
        godMode = !godMode;
        const btn = document.getElementById('god-mode-btn');
        btn.innerText = 'GOD MODE: ' + (godMode ? 'ON' : 'OFF');
        btn.style.color = godMode ? '#00ff00' : '#fff';
    }

    function devToggleSuperDamage() {
        superDamage = !superDamage;
        const btn = document.getElementById('super-dmg-btn');
        btn.innerText = 'SUPER DAMAGE: ' + (superDamage ? 'ON' : 'OFF');
        btn.style.color = superDamage ? '#00ff00' : '#fff';
    }

    function devNuke() { spawnNukePickup(); toggleDevMenu(); }

    const setKey = (k, v) => {
        if(k === 'w' || k === 'W') keys.w = v; if(k === 'a' || k === 'A') keys.a = v;
        if(k === 's' || k === 'S') keys.s = v; if(k === 'd' || k === 'D') keys.d = v;
        if(k === ' ' || k === 'Space') keys.space = v; if(k === 'Shift') keys.shift = v;
    };
    
    window.addEventListener('keydown', e => {
        setKey(e.key, true);
        if (e.key === 'l' || e.key === 'L') toggleDevMenu();
        if (e.key === 'p' || e.key === 'P') togglePause();
        if (e.key === 'Shift' && isGameRunning) { if (!player.focusActive && player.focus >= player.maxFocus) { player.focusActive = true; Audio.slowMoStart(); } }
    });
    window.addEventListener('keyup', e => setKey(e.key, false));
    window.addEventListener('mousemove', e => { mouse.x = e.clientX; mouse.y = e.clientY; });
    window.addEventListener('mousedown', (e) => { if (e.button === 0) mouse.left = true; if (e.button === 2) mouse.right = true; });
    window.addEventListener('mouseup', (e) => { if (e.button === 0) mouse.left = false; if (e.button === 2) mouse.right = false; });

    function setWeapon(type) {
        player.weapon = type; player.ammo = WEAPONS[type].ammo; player.minigunWindup = 0;
        updateUI(); Audio.pickup();
    }

    function setSecondary(type) {
        // If already has same secondary, add ammo
        if (player.secondaryWeapon === type) {
            player.secondaryAmmo = Math.min(SECONDARIES[type].maxAmmo, player.secondaryAmmo + SECONDARIES[type].ammo);
        } else {
            player.secondaryWeapon = type;
            player.secondaryAmmo = SECONDARIES[type].ammo;
        }
        updateUI(); Audio.pickup();
    }
    
    function addAmmo(type) {
        const w = WEAPONS[type]; player.ammo = Math.min(w.maxCarry, player.ammo + w.ammo);
        updateUI(); Audio.pickup();
    }

    function normalizeAngle(angle) {
        while (angle > Math.PI) angle -= Math.PI * 2;
        while (angle < -Math.PI) angle += Math.PI * 2;
        return angle;
    }

    class Bullet {
        constructor(x, y, angle, speed, color, damage, explosive = false, pierce = false, isEnemy = false, weaponType = null) {
            this.x = x; this.y = y; this.angle = angle;
            this.vx = Math.cos(angle) * speed; this.vy = Math.sin(angle) * speed;
            this.life = 60; this.color = color; this.damage = damage;
            this.explosive = explosive; this.pierce = pierce; this.isEnemy = isEnemy; this.hitList = []; 
            this.weaponType = weaponType;
        }
        update(dt) {
            this.x += this.vx * dt; this.y += this.vy * dt; this.life -= 1 * dt;
        }
        draw(ctx) {
            ctx.save(); ctx.translate(this.x, this.y); ctx.rotate(this.angle);
            ctx.fillStyle = this.color;
            if (this.pierce) {
                ctx.fillStyle = '#ffffff'; ctx.fillRect(-40, -3, 80, 6);
                ctx.fillStyle = this.color; ctx.globalAlpha = 0.6; ctx.fillRect(-50, -6, 100, 12);
            } else if (this.explosive) {
                ctx.fillRect(-8, -3, 16, 6); ctx.fillStyle = '#ff8800'; ctx.fillRect(-8, -1, 4, 2); 
            } else if (this.isEnemy) {
                ctx.fillStyle = '#ff0000'; ctx.beginPath(); ctx.arc(0, 0, 5, 0, Math.PI*2); ctx.fill();
            } else {
                ctx.fillRect(-6, -2, 12, 4);
            }
            ctx.restore();
        }
    }

    class Grenade {
        constructor(x, y, angle, isCluster = false) {
            this.x = x; this.y = y;
            const spd = isCluster ? 15 : 10;
            this.vx = Math.cos(angle) * spd; this.vy = Math.sin(angle) * spd;
            this.life = 60; this.radius = isCluster ? 8 : 6;
            this.isCluster = isCluster;
            this.friction = isCluster ? 0.03 : 0.05;
        }
        update(dt) {
            this.x += this.vx * dt; this.y += this.vy * dt;
            this.vx *= (1 - (this.friction * dt)); this.vy *= (1 - (this.friction * dt));
            this.life -= 1 * dt;
        }
        draw(ctx) {
            ctx.fillStyle = this.isCluster ? '#ffaa00' : '#4488ff'; 
            ctx.beginPath(); ctx.arc(this.x, this.y, this.radius, 0, Math.PI*2); ctx.fill();
            if (Math.floor(Date.now() / 100) % 2 === 0) { ctx.fillStyle = '#fff'; ctx.beginPath(); ctx.arc(this.x+2, this.y-2, 3, 0, Math.PI*2); ctx.fill(); }
        }
    }

    class Mine {
        constructor(x, y) {
            this.x = x; this.y = y;
            this.life = 3600; // 60 seconds
            this.radius = 15;
            this.triggerRadius = 40;
            this.active = false;
            setTimeout(() => { this.active = true; Audio.mineSet(); }, 1000);
        }
        update(dt) {
            if (!this.active) return;
            this.life -= dt;
            for(let e of enemies) {
                if(Math.hypot(e.x - this.x, e.y - this.y) < this.triggerRadius) {
                    this.life = 0;
                    createExplosion(this.x, this.y, false, true); // true = isMine
                    break;
                }
            }
        }
        draw(ctx) {
            ctx.save(); ctx.translate(this.x, this.y);
            ctx.fillStyle = '#333'; ctx.beginPath(); ctx.arc(0, 0, 8, 0, Math.PI*2); ctx.fill();
            // Blink red
            if (!this.active) ctx.fillStyle = '#ffaa00';
            else ctx.fillStyle = Math.floor(Date.now()/200)%2===0 ? '#ff0000' : '#550000';
            ctx.beginPath(); ctx.arc(0, 0, 4, 0, Math.PI*2); ctx.fill();
            ctx.strokeStyle = '#333'; ctx.beginPath(); ctx.arc(0,0, this.triggerRadius, 0, Math.PI*2); 
            ctx.setLineDash([5, 5]); ctx.stroke();
            ctx.restore();
        }
    }

    class Turret {
        constructor(x, y, angle) {
            this.x = x; this.y = y;
            this.vx = Math.cos(angle) * 10; this.vy = Math.sin(angle) * 10;
            this.deployed = false;
            this.life = 100000; 
            this.angle = angle; // Start facing player
            this.fireTimer = 0;
            this.maxAmmo = 120 * 1.5; 
            this.ammo = this.maxAmmo;
        }
        update(dt) {
            if (!this.deployed) {
                this.x += this.vx * dt; this.y += this.vy * dt;
                this.vx *= 0.9; this.vy *= 0.9;
                if (Math.hypot(this.vx, this.vy) < 0.5) { this.deployed = true; Audio.mineSet(); }
            } else {
                if (this.ammo <= 0) { this.life = 0; return; }
                
                this.fireTimer -= dt * 16.6; 
                
                let closest = null; let minD = 500;
                for(let e of enemies) {
                    let d = Math.hypot(e.x - this.x, e.y - this.y);
                    if (d < minD) { minD = d; closest = e; }
                }
                
                if (closest) {
                    const targetAngle = Math.atan2(closest.y - this.y, closest.x - this.x);
                    
                    // Rotation Logic
                    let diff = targetAngle - this.angle;
                    while (diff > Math.PI) diff -= Math.PI * 2;
                    while (diff < -Math.PI) diff += Math.PI * 2;
                    
                    const turnSpeed = 0.05 * dt; // Reduced speed (was 0.1)
                    if (Math.abs(diff) < turnSpeed) this.angle = targetAngle;
                    else this.angle += Math.sign(diff) * turnSpeed;

                    // Fire if aimed
                    if (Math.abs(diff) < 0.5 && this.fireTimer <= 0) {
                        const w = WEAPONS.smg;
                        const spread = (Math.random() - 0.5) * 0.2; // Add Spread
                        bullets.push(new Bullet(this.x, this.y, this.angle + spread, w.speed, '#44ff44', w.damage));
                        Audio.shoot();
                        this.ammo--;
                        this.fireTimer = w.rate; 
                    }
                } else {
                    this.angle += 0.05 * dt; // Scan
                }
            }
        }
        draw(ctx) {
            ctx.save(); ctx.translate(this.x, this.y);
            // Legs
            ctx.fillStyle = '#555';
            if (this.deployed) {
                 ctx.beginPath(); ctx.moveTo(0,0); ctx.lineTo(-10, 10); ctx.stroke();
                 ctx.beginPath(); ctx.moveTo(0,0); ctx.lineTo(10, 10); ctx.stroke();
                 ctx.beginPath(); ctx.moveTo(0,0); ctx.lineTo(0, -12); ctx.stroke();
            }
            // Head
            ctx.rotate(this.angle);
            ctx.fillStyle = '#222'; ctx.fillRect(-6, -6, 12, 12);
            ctx.fillStyle = '#44ff44'; ctx.fillRect(2, -2, 8, 4);
            ctx.restore();
        }
    }

    class Pickup {
        constructor(x, y, type) {
            this.x = x; this.y = y; this.type = type; this.life = 1380; this.bob = 0;
            if (type === 'nuke') {
                this.spawnSide = Math.random() < 0.5 ? 'left' : 'right';
                this.y = arena.y + 100 + Math.random() * (arena.h - 200); this.baseY = this.y;
                if (this.spawnSide === 'left') { this.x = arena.x - 500; this.dir = 1; } else { this.x = arena.x + arena.w + 500; this.dir = -1; }
                this.life = 3000; this.waveOffset = Math.random() * 100;
            }
        }
        update(dt) {
            this.life -= 1 * dt; this.bob += 0.1 * dt;
            if (this.type === 'nuke') {
                this.x += 2.0 * this.dir * dt; 
                this.y = this.baseY + Math.sin((this.x * 0.005) + this.waveOffset) * 100;
            }
        }
        draw(ctx) {
            let yOff = Math.sin(this.bob) * 3; let xOff = 0;
            if (this.life < 360) {
                if (Math.floor(Date.now() / (this.life < 180 ? 50 : 200)) % 2 === 0) ctx.globalAlpha = 0.5;
                if (this.life < 180) xOff = (Math.random() - 0.5) * 4;
            }
            ctx.save(); ctx.translate(this.x + xOff, this.y + yOff);
            if (this.type === 'nuke') {
                ctx.globalAlpha = 1.0; ctx.fillStyle = '#ffff00';
                ctx.beginPath(); ctx.arc(0, 0, 15, 0, Math.PI*2); ctx.fill();
                ctx.fillStyle = '#000'; ctx.font = '20px Arial'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillText('☢', 0, 2);
                ctx.shadowBlur = 15; ctx.shadowColor = '#ffff00'; ctx.strokeStyle = '#fff'; ctx.lineWidth = 2; ctx.stroke(); ctx.shadowBlur = 0;
            } else if (this.type === 'medikit') {
                ctx.fillStyle = '#fff'; ctx.fillRect(-16, -10, 32, 20);
                ctx.fillStyle = '#00ff00'; ctx.fillRect(-4, -8, 8, 16); ctx.fillRect(-8, -4, 16, 8);
                ctx.strokeStyle = '#00ff00'; ctx.strokeRect(-16, -10, 32, 20);
            } else {
                // Check if secondary
                if (SECONDARIES[this.type]) {
                    const s = SECONDARIES[this.type];
                    // Pentagon Shape for Secondary
                    ctx.fillStyle = '#111'; 
                    ctx.beginPath();
                    ctx.moveTo(0, -15);
                    ctx.lineTo(15, -5);
                    ctx.lineTo(10, 12);
                    ctx.lineTo(-10, 12);
                    ctx.lineTo(-15, -5);
                    ctx.closePath();
                    ctx.fill();
                    
                    ctx.fillStyle = s.color; ctx.font = '10px Arial'; ctx.textAlign = 'center'; ctx.fillText(s.name.substring(0,3), 0, 5);
                    ctx.strokeStyle = s.color; ctx.stroke();
                } else {
                    const w = WEAPONS[this.type]; ctx.fillStyle = '#222'; 
                    ctx.fillRect(-16, -10, 32, 20);
                    ctx.fillStyle = w.color; ctx.font = '12px Arial'; ctx.fillText(w.name.substring(0,2), -10, 5);
                    ctx.strokeStyle = w.color; ctx.strokeRect(-16, -10, 32, 20);
                }
            }
            ctx.restore(); ctx.globalAlpha = 1.0;
        }
    }

    class Debris {
        constructor(x, y, color) {
            this.x = x; this.y = y;
            const angle = Math.random() * Math.PI * 2; const speed = Math.random() * 8 + 2;
            this.vx = Math.cos(angle) * speed; this.vy = Math.sin(angle) * speed;
            this.rotation = Math.random() * Math.PI * 2; this.rotSpeed = (Math.random() - 0.5) * 0.5;
            this.life = 1.0; this.color = color; this.size = 4 + Math.random() * 6; this.w = this.size; this.h = this.size * 0.6; 
        }
        update(dt) {
            this.x += this.vx * dt; this.y += this.vy * dt;
            this.vx *= (1 - (0.1 * dt)); this.vy *= (1 - (0.1 * dt));
            this.rotation += this.rotSpeed * dt; this.rotSpeed *= (1 - (0.05 * dt));
            if (Math.abs(this.vx) < 0.1 && Math.abs(this.vy) < 0.1) this.life -= 0.05 * dt; 
        }
        draw(ctx) {
            ctx.save(); ctx.translate(this.x, this.y); ctx.rotate(this.rotation);
            ctx.fillStyle = this.color; ctx.fillRect(-this.w/2, -this.h/2, this.w, this.h);
            ctx.restore();
        }
    }
    
    class BossFragment {
        constructor(x, y) {
            this.x = x; this.y = y;
            const angle = Math.random() * Math.PI * 2;
            const speed = Math.random() * 8 + 2;
            this.vx = Math.cos(angle) * speed;
            this.vy = Math.sin(angle) * speed;
            this.rotation = Math.random() * Math.PI * 2;
            this.rotSpeed = (Math.random() - 0.5) * 0.4;
            
            // Random shard shape
            this.points = [];
            const r = 20 + Math.random() * 30;
            const sides = 3 + Math.floor(Math.random() * 3);
            for(let i=0; i<sides; i++) {
                const a = (i/sides)*Math.PI*2 + (Math.random()*0.5);
                this.points.push({x: Math.cos(a)*r, y: Math.sin(a)*r});
            }
        }
        update(dt) {
            this.x += this.vx * dt; this.y += this.vy * dt;
            this.vx *= 0.92; this.vy *= 0.92; // High friction, stop quickly
            this.rotation += this.rotSpeed * dt;
            this.rotSpeed *= 0.92;
        }
        draw(ctx) {
            ctx.save();
            ctx.translate(this.x, this.y);
            ctx.rotate(this.rotation);
            ctx.fillStyle = '#1f101f'; // Boss body color
            ctx.strokeStyle = '#ffaa00'; // Boss glow color CHANGED to Orange
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(this.points[0].x, this.points[0].y);
            for(let i=1; i<this.points.length; i++) ctx.lineTo(this.points[i].x, this.points[i].y);
            ctx.closePath();
            ctx.fill();
            ctx.stroke();
            ctx.restore();
        }
    }

    class Enemy {
        constructor(typeOverride) {
            this.type = 'zombie'; this.facing = 0; this.dead = false; this.dying = false; this.dyingTimer = 0;
            
            this.bossState = 'chase'; this.bossTimer = 0; this.chargeDir = {x:0, y:0}; this.chargeCooldown = 900 + Math.random() * 1500; 

            this.tankState = 'stroll'; this.tankTimer = 60 + Math.random() * 120; this.aggroTime = 0;
            
            // SPAWN LOGIC REBALANCED
            if (typeOverride) { this.type = typeOverride; } 
            else {
                const r = Math.random();
                if (wave < 5) {
                     this.type = 'zombie';
                }
                else if (wave < 10) { 
                    // Waves 5-9: Tanks introduced
                    if (r < 0.1) this.type = 'tank';
                    else this.type = 'zombie';
                } 
                else if (wave < 15) {
                    // Waves 10-14: Flankers introduced
                    if (r < 0.2) this.type = 'flanker';
                    else if (r < 0.3) this.type = 'tank';
                    else this.type = 'zombie';
                }
                else {
                    // Waves 15+: Blinds introduced + Mix
                    if (r < 0.4) this.type = 'zombie';
                    else if (r < 0.6) this.type = 'flanker';
                    else if (r < 0.8) this.type = 'blind'; 
                    else this.type = 'tank';
                }
            }

            if (this.type === 'boss') Audio.spawnBoss();
            else if (this.type === 'tank') Audio.spawnTank();
            else if (this.type === 'flanker') Audio.spawnFlanker();
            else if (this.type === 'blind') Audio.spawnBlind();

            const spawnDist = this.type === 'boss' ? 200 : 40;
            if (Math.random() < 0.5) { this.x = arena.x + Math.random() * arena.w; this.y = Math.random() < 0.5 ? arena.y - spawnDist : arena.y + arena.h + spawnDist; } 
            else { this.x = Math.random() < 0.5 ? arena.x - spawnDist : arena.x + arena.w + spawnDist; this.y = arena.y + Math.random() * arena.h; }

            this.vx = 0; this.vy = 0;
            
            if (this.type === 'tank') {
                 const tx = arena.x + arena.w/2 + (Math.random()-0.5)*100;
                 const ty = arena.y + arena.h/2 + (Math.random()-0.5)*100;
                 this.facing = Math.atan2(ty - this.y, tx - this.x);
                 this.hp = 25 + (wave * 2); this.speed = 1.1; this.radius = 26; this.color = '#3e2723';
            } else {
                switch(this.type) {
                    case 'zombie': this.hp = 2 + Math.floor(wave/5); this.speed = (0.5 + Math.random() * 0.5) * 0.8; this.radius = 12; this.color = '#448844'; break;
                    case 'flanker': this.hp = (4 + wave) * 0.7; this.speed = (2.2) * 0.8 * 0.9; this.radius = 12; this.color = '#aa33ff'; this.flankDir = Math.random() < 0.5 ? 1 : -1; break;
                    case 'blind': this.hp = 8 + wave; this.speed = (3.0) * 0.8; this.radius = 14; this.color = '#888888'; break;
                    case 'boss': this.hp = 5000 + (wave * 200); this.speed = 0.8; this.radius = 100; this.color = '#1f101f'; break;
                }
            }
            this.maxHp = this.hp; 
        }

        update(dt) {
            // BOSS DYING ANIMATION LOGIC
            if (this.dying) {
                this.dyingTimer += dt * 16.6;
                shakeX = (Math.random() - 0.5) * 15;
                shakeY = (Math.random() - 0.5) * 15;
                if (Math.random() < 0.3) {
                    const ex = this.x + (Math.random()-0.5) * this.radius * 2;
                    const ey = this.y + (Math.random()-0.5) * this.radius * 2;
                    createExplosion(ex, ey);
                }
                if (this.dyingTimer > 2500) {
                    this.dead = true;
                    // Spawn Egg Shell Fragments
                    for(let i=0; i<6; i++) {
                        corpses.push(new BossFragment(this.x, this.y));
                    }
                    killEnemy(this, 0); 
                    detonateNuke(this.x, this.y); 
                }
                return; 
            }

            let dx = player.x - this.x; let dy = player.y - this.y;
            let dist = Math.sqrt(dx*dx + dy*dy); let targetAngle = Math.atan2(dy, dx);
            
            // --- AI STATE MACHINE ---
            if (this.type === 'boss') {
                // BOSS AI
                if (this.bossState === 'chase') {
                    let delta = normalizeAngle(targetAngle - this.facing);
                    this.facing += Math.sign(delta) * 0.008 * dt;
                    this.vx += Math.cos(this.facing) * 0.05 * dt; this.vy += Math.sin(this.facing) * 0.05 * dt;
                    this.bossTimer += dt;
                    if (this.bossTimer > this.chargeCooldown) { this.bossState = 'charge_prep'; this.bossTimer = 0; Audio.bossCharge(); }
                } 
                else if (this.bossState === 'charge_prep') {
                    this.vx *= 0.8; this.vy *= 0.8;
                    let delta = normalizeAngle(targetAngle - this.facing);
                    this.facing += Math.sign(delta) * 0.1 * dt;
                    this.bossTimer += dt;
                    if (this.bossTimer > 120) { 
                        this.bossState = 'charge'; this.bossTimer = 0;
                        this.chargeDir.x = Math.cos(this.facing); this.chargeDir.y = Math.sin(this.facing);
                        this.chargeCooldown = 900 + Math.random() * 1500; 
                    }
                } 
                else if (this.bossState === 'charge') {
                    const chargeSpeed = 11;
                    this.x += this.chargeDir.x * chargeSpeed * dt; this.y += this.chargeDir.y * chargeSpeed * dt;
                    
                    // Specific Charge Hit Logic for Damage
                    for (let other of enemies) {
                        if (other === this) continue;
                        const odx = other.x - this.x; const ody = other.y - this.y;
                        const odist = Math.sqrt(odx*odx + ody*ody);
                        if (odist < this.radius + other.radius + 20) {
                             const angle = Math.atan2(ody, odx);
                             if (other.type === 'tank') {
                                 other.hp = 0; other.dead = true; killEnemy(other, angle);
                                 Audio.tankDeath(); createExplosion(other.x, other.y);
                             } else if (other.type !== 'boss') {
                                 // Don't kill other bosses, just normal enemies
                                 const force = 30; 
                                 other.vx += Math.cos(angle) * force * dt; other.vy += Math.sin(angle) * force * dt;
                                 other.hp -= 5; 
                                 if (other.hp <= 0 && !other.dead) { other.dead = true; killEnemy(other, angle); }
                             }
                        }
                    }
                    if (this.x < arena.x || this.x > arena.x + arena.w || this.y < arena.y || this.y > arena.y + arena.h) {
                        this.bossState = 'chase'; this.bossTimer = 0; Audio.bossImpact(); shakeX = 20; shakeY = 20;
                        this.x = Math.max(arena.x, Math.min(arena.x + arena.w, this.x));
                        this.y = Math.max(arena.y, Math.min(arena.y + arena.h, this.y));
                    }
                    this.bossTimer += dt;
                    if (this.bossTimer > 90) { this.bossState = 'chase'; this.bossTimer = 0; }
                }
                
                if (this.bossState !== 'charge') {
                    this.vx *= 0.95; this.vy *= 0.95;
                    this.x += this.vx * dt; this.y += this.vy * dt;
                }

                if (!godMode && dist < this.radius + 15) {
                    player.hp -= (this.bossState === 'charge' ? 10 : 5); 
                    updateUI(); Audio.playerDamage(); 
                    const angle = Math.atan2(player.y - this.y, player.x - this.x);
                    const force = this.bossState === 'charge' ? 80 : 15;
                    player.vx += Math.cos(angle) * force; 
                    player.vy += Math.sin(angle) * force;
                    shakeX = 10; shakeY = 10;
                    if (player.hp <= 0) endGame();
                }
                // REMOVED 'return' so collision code below runs!
            }
            else {
                // NORMAL ENEMY AI
                this.vx *= (1 - (0.2 * dt)); this.vy *= (1 - (0.2 * dt));
                let moveX = 0, moveY = 0;
                
                if (dist > 0) {
                    let ndx = dx / dist; let ndy = dy / dist;
                    
                    if (this.type === 'tank') {
                        if (this.tankState === 'aggro') {
                            let delta = normalizeAngle(targetAngle - this.facing);
                            const turnSpeed = 0.005 * dt; 
                            if (Math.abs(delta) < turnSpeed) this.facing = targetAngle;
                            else this.facing += Math.sign(delta) * turnSpeed;
                            moveX = Math.cos(this.facing); moveY = Math.sin(this.facing);
                            this.aggroTime -= dt;
                            if (this.aggroTime <= 0) { this.tankState = 'idle'; this.tankTimer = 60 + Math.random() * 60; }
                        } else if (this.tankState === 'stroll') {
                            moveX = Math.cos(this.facing) * 0.4; moveY = Math.sin(this.facing) * 0.4;
                            this.tankTimer -= dt;
                            const pad = 100;
                            if (this.x < arena.x + pad || this.x > arena.x + arena.w - pad || 
                                this.y < arena.y + pad || this.y > arena.y + arena.h - pad) {
                                 const cx = arena.x + arena.w/2; const cy = arena.y + arena.h/2;
                                 this.facing = Math.atan2(cy - this.y, cx - this.x) + (Math.random()-0.5);
                            }
                            if (this.tankTimer <= 0) { this.tankState = 'idle'; this.tankTimer = 60 + Math.random() * 120; }
                        } else {
                            moveX = 0; moveY = 0; this.tankTimer -= dt;
                            if (this.tankTimer <= 0) {
                                this.tankState = 'stroll'; this.tankTimer = 120 + Math.random() * 120;
                                this.facing = Math.random() * Math.PI * 2;
                            }
                        }
                    } 
                    else if (this.type === 'flanker') {
                        moveX = ndx + (-ndy * 0.8 * this.flankDir); moveY = ndy + (ndx * 0.8 * this.flankDir);
                        this.facing = Math.atan2(moveY, moveX);
                    } else if (this.type === 'blind') {
                        if (noisePos) {
                            let nDx = noisePos.x - this.x; let nDy = noisePos.y - this.y;
                            let nDist = Math.sqrt(nDx*nDx + nDy*nDy);
                            if (nDist > 5) { moveX = nDx / nDist; moveY = nDy / nDist; this.facing = Math.atan2(moveY, moveX); }
                        } else { moveX = (Math.random() - 0.5) * 0.2; moveY = (Math.random() - 0.5) * 0.2; this.facing += (Math.random()-0.5)*0.1 * dt; }
                    } else {
                        moveX = ndx; moveY = ndy; this.facing = targetAngle;
                    }
                    const moveLen = Math.sqrt(moveX*moveX + moveY*moveY);
                    if (moveLen > 0 && this.type !== 'tank') { moveX /= moveLen; moveY /= moveLen; }
                    if (Math.abs(this.vx) < 1 && Math.abs(this.vy) < 1) { this.x += moveX * this.speed * dt; this.y += moveY * this.speed * dt; }
                }
                this.x += this.vx * dt; this.y += this.vy * dt;
            }
            
            // --- SHARED COLLISION / SEPARATION LOGIC ---
            // Now runs for BOTH Bosses and Normal Enemies
            let sepX = 0; let sepY = 0; let neighborCount = 0;
            
            for (let other of enemies) {
                if (other === this) continue;
                const dx2 = this.x - other.x; const dy2 = this.y - other.y;
                const dist2 = Math.sqrt(dx2*dx2 + dy2*dy2);
                const minSpace = this.radius + other.radius;

                if (dist2 < minSpace && dist2 > 0) {
                    const overlap = minSpace - dist2;
                    const angle = Math.atan2(dy2, dx2);

                    // CASE 1: BOSS vs BOSS (Hard Position Separation)
                    if (this.type === 'boss' && other.type === 'boss') {
                        // Push away by half overlap
                        this.x += Math.cos(angle) * overlap * 0.5;
                        this.y += Math.sin(angle) * overlap * 0.5;
                    }
                    // CASE 2: BOSS vs NORMAL (This is Boss)
                    else if (this.type === 'boss') {
                        // Do nothing. Boss is an unstoppable object to normal enemies.
                        // The loop running for 'other' (the normal enemy) will handle the push out.
                    }
                    // CASE 3: NORMAL vs BOSS (This is Normal)
                    else if (other.type === 'boss') {
                        // HARD WALL: Push normal enemy completely out of boss
                        this.x += Math.cos(angle) * overlap;
                        this.y += Math.sin(angle) * overlap;
                    }
                    // CASE 4: BLIND SWARM (Velocity Separation)
                    else if (this.type === 'blind') {
                        sepX += (this.x - other.x) / dist2;
                        sepY += (this.y - other.y) / dist2;
                        neighborCount++;
                    }
                    // CASE 5: NORMAL vs NORMAL (Soft Bounce)
                    else {
                        let force = 0.5 * dt; 
                        this.x += Math.cos(angle) * force; 
                        this.y += Math.sin(angle) * force;
                    }
                }
            }

            // Apply Blind Swarm Force
            if (this.type === 'blind' && neighborCount > 0) {
                this.vx += (sepX / neighborCount) * 1.5 * dt;
                this.vy += (sepY / neighborCount) * 1.5 * dt;
            }
        }

        draw(ctx) {
            ctx.save();
            ctx.translate(this.x, this.y);

            // DYING ANIMATION
            if (this.dying) {
                const shake = Math.sin(Date.now() / 20) * 5;
                ctx.translate(shake, shake);
                ctx.globalAlpha = 0.7 + Math.sin(Date.now()/50) * 0.3;
                // Flash white
                if (Math.floor(Date.now() / 100) % 2 === 0) {
                     ctx.fillStyle = '#ffffff';
                     ctx.beginPath(); ctx.arc(0, 0, this.radius, 0, Math.PI*2); ctx.fill();
                     ctx.restore();
                     return;
                }
            }

            if (this.type === 'boss') {
                ctx.rotate(this.facing);
                
                ctx.fillStyle = '#00ffff'; ctx.beginPath(); ctx.arc(-this.radius + 10, 0, 15, 0, Math.PI*2); ctx.fill();
                ctx.fillStyle = 'rgba(0, 255, 255, 0.5)'; ctx.beginPath(); ctx.arc(-this.radius + 10, 0, 25 + Math.sin(Date.now()/100)*5, 0, Math.PI*2); ctx.fill();

                if (this.bossState === 'charge_prep') {
                     ctx.shadowBlur = 30; ctx.shadowColor = '#ff0000'; ctx.fillStyle = 'rgba(255, 0, 0, 0.3)';
                     ctx.beginPath(); ctx.arc(0, 0, this.radius + 20, 0, Math.PI*2); ctx.fill();
                } else { ctx.shadowBlur = 0; }

                const pulse = Math.sin(Date.now() / 200) * 3;
                ctx.fillStyle = this.bossState === 'charge_prep' ? '#500' : '#303';
                ctx.beginPath(); ctx.arc(0, 0, this.radius + 5 + pulse, 0, Math.PI*2); ctx.fill();

                ctx.fillStyle = this.bossState === 'charge_prep' ? '#300' : '#1a051a'; 
                ctx.beginPath();
                for (let i = 0; i < Math.PI * 2; i += 0.2) {
                    let r = this.radius + Math.sin(i * 7 + Date.now()/400)*3;
                    ctx.lineTo(Math.cos(i) * r, Math.sin(i) * r);
                }
                ctx.closePath(); ctx.fill();

                ctx.shadowBlur = 0; 
                const eyePositions = [
                    {x: 25, y: -15, r: 9}, {x: 35, y: 8, r: 11}, {x: 15, y: 22, r: 7},
                    {x: 50, y: -8, r: 6}, {x: 8, y: -30, r: 7}, {x: -15, y: 8, r: 6}, {x: 15, y: 0, r: 5}
                ];
                const aliveEyesCount = Math.ceil((this.hp / this.maxHp) * eyePositions.length);
                eyePositions.forEach((eye, index) => {
                    ctx.beginPath();
                    let jx = this.bossState === 'charge_prep' ? (Math.random()-0.5)*3 : 0;
                    let jy = this.bossState === 'charge_prep' ? (Math.random()-0.5)*3 : 0;
                    if (index < aliveEyesCount) { ctx.fillStyle = '#ffaa00'; } else { ctx.fillStyle = '#440000'; }
                    ctx.arc(eye.x + jx, eye.y + jy, eye.r, 0, Math.PI*2);
                    ctx.fill();
                });
                if (this.bossState === 'charge') {
                    ctx.fillStyle = 'rgba(255, 0, 0, 0.2)';
                    ctx.fillRect(-this.radius*1.5, -this.radius, this.radius, this.radius*2);
                }
                ctx.shadowBlur = 0;
            }
            else if (this.type === 'tank') {
                ctx.rotate(this.facing);
                ctx.fillStyle = this.color; ctx.beginPath(); ctx.ellipse(0, 0, this.radius+5, this.radius-5, 0, 0, Math.PI*2); ctx.fill();
                ctx.fillStyle = '#281a17'; ctx.beginPath(); ctx.arc(10, 0, this.radius-8, -Math.PI/2, Math.PI/2); ctx.fill();
                ctx.fillStyle = this.tankState === 'aggro' ? '#ff0000' : '#ff9900';
                ctx.beginPath(); ctx.arc(-15, 0, 8, 0, Math.PI*2); ctx.fill();
            } 
            else {
                ctx.rotate(this.facing); ctx.fillStyle = this.color; ctx.beginPath(); ctx.arc(0, 0, this.radius, 0, Math.PI*2); ctx.fill();
                if (this.type !== 'blind') {
                    ctx.fillStyle = '#ffff00'; ctx.beginPath(); ctx.arc(6, 4, 3, 0, Math.PI*2); ctx.arc(6, -4, 3, 0, Math.PI*2); ctx.fill();
                } else if (this.type === 'blind') {
                    ctx.strokeStyle = '#333'; ctx.beginPath(); ctx.arc(0,0, this.radius-4, 0, Math.PI*2); ctx.stroke();
                }
            }
            ctx.restore();
        }
    }

    class Particle {
        constructor(x, y, color, speed, friction = 0.9) {
            this.x = x; this.y = y;
            const angle = Math.random() * Math.PI * 2; const vel = Math.random() * speed;
            this.vx = Math.cos(angle) * vel; this.vy = Math.sin(angle) * vel;
            this.life = 1.0; this.decay = 0.02 + Math.random() * 0.03; this.color = color; this.friction = friction;
        }
        update(dt) {
            this.x += this.vx * dt; this.y += this.vy * dt;
            this.vx *= (1 - ((1-this.friction) * dt)); this.vy *= (1 - ((1-this.friction) * dt));
            this.life -= this.decay * dt;
        }
        draw(ctx) {
            ctx.globalAlpha = this.life; ctx.fillStyle = this.color; ctx.fillRect(this.x, this.y, 4, 4); ctx.globalAlpha = 1.0;
        }
    }

    function update(realTime) {
        if (!isGameRunning || isPaused) return;
        if (hitStop > 0) { hitStop--; return; }

        let dt = 1.0;
        if (player.focusActive) {
            dt = SLOW_MO_FACTOR; player.focus -= FOCUS_DRAIN;
            if (player.focus <= 0) { player.focus = 0; player.focusActive = false; Audio.slowMoEnd(); }
        } else {
            if (player.focus < player.maxFocus) { player.focus += FOCUS_REGEN; if (player.focus > player.maxFocus) player.focus = player.maxFocus; }
        }
        
        document.getElementById('dash-fill').style.width = Math.min(100, (Math.min(1, (gameTime - (lastDashTime + DASH_DURATION)) / DASH_COOLDOWN)) * 100) + '%';
        document.getElementById('focus-fill').style.width = player.focus + '%';

        gameTime += 16.6 * dt; 

        const camTargetX = player.x - width / 2;
        const camTargetY = player.y - height / 2;
        // Smoother camera lerp (0.04) - "Lazier" follow to reduce shake
        camera.x += (camTargetX - camera.x) * 0.04;
        camera.y += (camTargetY - camera.y) * 0.04;
        camera.x = Math.max(0, Math.min(WORLD_SIZE - width, camera.x));
        camera.y = Math.max(0, Math.min(WORLD_SIZE - height, camera.y));

        if (wave >= 10 && arena.targetW < WORLD_SIZE - 200) { arena.targetW = WORLD_SIZE - 200; arena.targetH = WORLD_SIZE - 200; }
        if (arena.w < arena.targetW) {
            arena.w += 2 * dt; arena.h += 2 * dt;
            arena.x = (WORLD_SIZE - arena.w) / 2; arena.y = (WORLD_SIZE - arena.h) / 2;
        }

        const wp = WEAPONS[player.weapon];

        // PHYSICS BASED MOVEMENT LOGIC
        // 1. Get Input Vector
        let ix = 0; let iy = 0;
        if (keys.w) iy -= 1; if (keys.s) iy += 1;
        if (keys.a) ix -= 1; if (keys.d) ix += 1;
        if (ix !== 0 || iy !== 0) {
            const len = Math.hypot(ix, iy);
            ix /= len; iy /= len;
        }

        // 2. Apply Input Acceleration to Velocity
        player.vx += ix * PLAYER_ACCEL * dt;
        player.vy += iy * PLAYER_ACCEL * dt;

        // 3. Apply Friction to Velocity
        const frictionFactor = Math.pow(PLAYER_FRICTION, dt);
        player.vx *= frictionFactor;
        player.vy *= frictionFactor;

        // 4. Update Position
        player.x += player.vx * dt;
        player.y += player.vy * dt;

        // 5. Bounds Check
        if (player.x < arena.x + 10) { player.x = arena.x + 10; player.vx = 0; }
        if (player.x > arena.x + arena.w - 10) { player.x = arena.x + arena.w - 10; player.vx = 0; }
        if (player.y < arena.y + 10) { player.y = arena.y + 10; player.vy = 0; }
        if (player.y > arena.y + arena.h - 10) { player.y = arena.y + arena.h - 10; player.vy = 0; }

        const mouseWorldX = mouse.x + camera.x; const mouseWorldY = mouse.y + camera.y;
        player.angle = Math.atan2(mouseWorldY - player.y, mouseWorldX - player.x);

        let isDashing = (gameTime - lastDashTime < DASH_DURATION);
        const dashP = Math.min(1, (gameTime - (lastDashTime + DASH_DURATION)) / DASH_COOLDOWN);
        // document.getElementById('dash-bar').style.width = (dashP * 100) + '%';
        if (keys.space && !isDashing && dashP >= 1) {
            lastDashTime = gameTime; 
            isDashing = true; // Still used for logic/visuals
            
            // DASH IMPULSE - Apply burst of velocity
            let dashDirX = ix; let dashDirY = iy;
            if (dashDirX === 0 && dashDirY === 0) {
                // Dash towards mouse if no input
                dashDirX = Math.cos(player.angle);
                dashDirY = Math.sin(player.angle);
            }
            player.vx += dashDirX * DASH_IMPULSE;
            player.vy += dashDirY * DASH_IMPULSE;

            for(let i=0; i<10; i++) particles.push(new Particle(player.x, player.y, '#ffffff', 5));
            Audio.dash();
        }

        let shouldFire = false;
        if (mouse.left) {
            if (player.weapon === 'minigun') {
                if (player.minigunWindup === 0) Audio.minigunWindup();
                
                player.minigunWindup += dt * 16.6;
                player.minigunSoundTimer += dt * 16.6;
                if (player.minigunSoundTimer > 100) { Audio.minigunSpin(); player.minigunSoundTimer = 0; }
                
                if (player.minigunWindup > 500) shouldFire = true;
            } else {
                shouldFire = true;
            }
        } else {
            player.minigunWindup = 0;
        }

        if (shouldFire && gameTime - lastShotTime > wp.rate) {
            if (player.ammo > 0) {
                const mx = player.x + Math.cos(player.angle) * 20; const my = player.y + Math.sin(player.angle) * 20;
                
                let spreadFactor = wp.spread;
                if (player.weapon === 'minigun') {
                    // Spread based on movement speed
                    const speed = Math.hypot(player.vx, player.vy);
                    spreadFactor = 0.01 + (speed * 0.05); // Reduced multiplier since vx is now physics based
                }

                for(let i=0; i<wp.count; i++) {
                    const spread = (Math.random() - 0.5) * spreadFactor;
                    bullets.push(new Bullet(mx, my, player.angle + spread, wp.speed, wp.color, wp.damage, wp.explosive, wp.pierce, false, player.weapon));
                }
                
                // Recoil Impulse
                player.vx -= Math.cos(player.angle) * wp.recoil;
                player.vy -= Math.sin(player.angle) * wp.recoil;

                shakeX = Math.cos(player.angle + Math.PI) * wp.recoil; shakeY = Math.sin(player.angle + Math.PI) * wp.recoil;
                noisePos = { x: player.x, y: player.y }; lastShotTime = gameTime;
                particles.push(new Particle(player.x, player.y, '#aa8800', 3));
                if(player.weapon === 'shotgun') Audio.shotgun(); else if (player.weapon === 'rocket') Audio.rocket(); else Audio.shoot();
                if (player.ammo !== Infinity) { player.ammo--; if (player.ammo <= 0) setWeapon('pistol'); updateUI(); }
            } else if (player.weapon !== 'pistol') setWeapon('pistol');
        }

        // GRENADE / SECONDARY LOGIC
        if (mouse.right) {
            // Check for SPECIAL secondary first
            if (player.secondaryWeapon && player.secondaryAmmo > 0) {
                // Determine cooldown for special weapon
                let onCooldown = false;
                
                // Mine, Cluster, and generic use standard grenade cooldown
                // (User requested Cluster match normal grenade)
                if (gameTime - lastGrenadeTime < GRENADE_COOLDOWN) onCooldown = true;

                if (!onCooldown) {
                    lastGrenadeTime = gameTime;
                    
                    if (player.secondaryWeapon === 'mine') {
                         mines.push(new Mine(player.x, player.y));
                    } else if (player.secondaryWeapon === 'turret') {
                         turrets.push(new Turret(player.x, player.y, player.angle));
                    } else if (player.secondaryWeapon === 'cluster') {
                         grenades.push(new Grenade(player.x, player.y, player.angle, true));
                         // Cluster Recoil (Same as Normal Grenade)
                         player.vx -= Math.cos(player.angle) * 12;
                         player.vy -= Math.sin(player.angle) * 12;
                         Audio.rocket();
                    }
                    
                    player.secondaryAmmo--;
                    if (player.secondaryAmmo <= 0) {
                        player.secondaryWeapon = null;
                    }
                    updateUI();
                }
            } else {
                // Standard Grenade Logic
                const cdPercent = Math.min(1, (gameTime - lastGrenadeTime) / GRENADE_COOLDOWN);
                if (cdPercent >= 1) {
                     grenades.push(new Grenade(player.x, player.y, player.angle));
                     lastGrenadeTime = gameTime;
                     
                     // Grenade Recoil Impulse
                     player.vx -= Math.cos(player.angle) * 12;
                     player.vy -= Math.sin(player.angle) * 12;
        
                     noisePos = { x: player.x, y: player.y }; Audio.rocket();
                }
            }
        }
        
        // Update Grenade Bar Visuals (Handled in updateUI now for the new widget)
        updateUI(); // Keep visuals synced slightly better? Actually expensive. Let's just update the secondary bar if needed.
        if (player.secondaryWeapon) {
             const cdPercent = Math.min(1, (gameTime - lastGrenadeTime) / GRENADE_COOLDOWN);
             const sBar = document.getElementById('s-bar');
             if(sBar) {
                sBar.style.width = (cdPercent * 100) + '%';
                const sWidget = document.getElementById('secondary-widget');
                if (cdPercent >= 1) {
                    sBar.style.backgroundColor = SECONDARIES[player.secondaryWeapon].color;
                    sWidget.classList.add('active');
                } else {
                    sBar.style.backgroundColor = '#555';
                    sWidget.classList.remove('active');
                }
             }
        }

        for (let i = bullets.length - 1; i >= 0; i--) {
            bullets[i].update(dt); let b = bullets[i]; let remove = false;
            if (b.x < arena.x || b.x > arena.x + arena.w || b.y < arena.y || b.y > arena.y + arena.h) remove = true;
            if (b.life <= 0) remove = true;
            if (b.isEnemy && !remove) {
                const dist = Math.hypot(b.x - player.x, b.y - player.y);
                if (dist < 15) { 
                    if(!godMode) { player.hp -= b.damage; updateUI(); Audio.playerDamage(); shakeX = 5; shakeY = 5; if (player.hp <= 0) endGame(); }
                    remove = true;
                }
            }
            if (remove) { if (b.explosive) createExplosion(b.x, b.y); bullets.splice(i, 1); }
        }
        
        for (let i = grenades.length - 1; i >= 0; i--) {
            let g = grenades[i]; g.update(dt); let explode = false;
            for (let e of enemies) { if (Math.hypot(g.x - e.x, g.y - e.y) < e.radius + 5) explode = true; }
            if (g.life <= 0) explode = true; 
            if (explode) { 
                if (g.isCluster) {
                    createExplosion(g.x, g.y, true); // Big visual
                    // Spawn mini grenades
                    for(let k=0; k<8; k++) {
                        const a = (Math.PI*2/8)*k;
                        grenades.push(new Grenade(g.x, g.y, a, false));
                    }
                } else {
                    createExplosion(g.x, g.y); 
                }
                grenades.splice(i, 1); 
            }
        }

        // UPDATE MINES
        for (let i = mines.length - 1; i >= 0; i--) {
            mines[i].update(dt);
            if (mines[i].life <= 0) mines.splice(i, 1);
        }

        // UPDATE TURRETS
        for (let i = turrets.length - 1; i >= 0; i--) {
            turrets[i].update(dt);
            if (turrets[i].life <= 0) turrets.splice(i, 1);
        }

        // UPDATE BOSS FRAGMENTS
        for(let i = corpses.length - 1; i >= 0; i--) {
            if (corpses[i].update) corpses[i].update(dt);
        }

        if (gameTime - lastSpawnTime > Math.max(150, SPAWN_RATE - wave * 25)) {
            if (wave === 5 && Math.random() < 0.2) for(let k=0; k<3; k++) enemies.push(new Enemy('flanker'));
            else enemies.push(new Enemy());
            lastSpawnTime = gameTime;
        }

        let nukeInPlay = false; for(let p of pickups) { if(p.type === 'nuke') nukeInPlay = true; }
        if (wave >= 10 && !nukeInPlay && (gameTime - lastNukeSpawnTime > 45000)) { if (Math.random() < 0.0001) spawnNukePickup(); }

        let nukeDist = 99999;
        for (let i = pickups.length - 1; i >= 0; i--) {
            pickups[i].update(dt); if (pickups[i].life <= 0) { pickups.splice(i, 1); continue; }
            if (pickups[i].type === 'nuke') { const d = Math.hypot(pickups[i].x - player.x, pickups[i].y - player.y); if (d < nukeDist) nukeDist = d; }
            if (Math.hypot(player.x - pickups[i].x, player.y - pickups[i].y) < 25) { // Pickup radius slightly larger
                const p = pickups[i];
                if (p.type === 'nuke') detonateNuke(p.x, p.y);
                else if (p.type === 'medikit') { player.hp = Math.min(player.maxHp, player.hp + 25); updateUI(); Audio.pickup(); for(let k=0; k<10; k++) particles.push(new Particle(player.x, player.y, '#00ff00', 5)); }
                else if (SECONDARIES[p.type]) {
                    setSecondary(p.type);
                    for(let k=0; k<10; k++) particles.push(new Particle(player.x, player.y, SECONDARIES[p.type].color, 5));
                }
                else {
                    if (player.weapon === p.type) addAmmo(p.type); else setWeapon(p.type);
                    for(let k=0; k<10; k++) particles.push(new Particle(player.x, player.y, '#ffff00', 5));
                }
                pickups.splice(i, 1);
            }
        }

        for (let i = enemies.length - 1; i >= 0; i--) {
            let e = enemies[i]; if (e.dead) { enemies.splice(i, 1); continue; }
            e.update(dt);
            for (let j = bullets.length - 1; j >= 0; j--) {
                let b = bullets[j]; if (b.isEnemy) continue;
                const hitBox = e.type === 'boss' ? 80 : 40;
                if (Math.abs(e.x - b.x) > hitBox || Math.abs(e.y - b.y) > hitBox) continue; 
                if (b.hitList && b.hitList.includes(e)) continue;
                const dist = Math.hypot(e.x - b.x, e.y - b.y);
                if (dist < e.radius + 10) {
                    let damageCalc = superDamage ? 999999 : b.damage; 
                    
                    if (e.type === 'tank') {
                         e.tankState = 'aggro'; e.aggroTime = 900; 
                         let diff = Math.abs(normalizeAngle(b.angle - e.facing));
                         if (diff < Math.PI / 3) { damageCalc *= 5; Audio.crit(); for(let k=0; k<5; k++) particles.push(new Particle(e.x, e.y, '#ffaa00', 8)); }
                    } else if (e.type === 'boss') {
                        let hitAngle = Math.atan2(b.y - e.y, b.x - e.x);
                        let diff = Math.abs(normalizeAngle(hitAngle - e.facing));
                        if (diff > 2.0) { damageCalc *= 3; Audio.weakPoint(); for(let k=0; k<8; k++) particles.push(new Particle(b.x, b.y, '#00ffff', 10)); }
                        
                        if (b.weaponType === 'railgun') { 
                            damageCalc = e.maxHp / 38; 
                            if (superDamage) damageCalc = 999999;
                            Audio.bossZap(); 
                            for(let k=0; k<5; k++) particles.push(new Particle(b.x, b.y, '#ff00ff', 15)); 
                        }
                    }
                    e.hp -= damageCalc;
                    if (b.explosive) { createExplosion(b.x, b.y); bullets.splice(j, 1); } 
                    else if (b.pierce) { b.hitList.push(e); for(let k=0; k<3; k++) particles.push(new Particle(e.x, e.y, e.color, 5)); } 
                    else {
                        if (e.type !== 'boss') { const kb = (e.type === 'tank' ? 2 : 8); e.vx += Math.cos(b.angle) * kb; e.vy += Math.sin(b.angle) * kb; }
                        bullets.splice(j, 1); for(let k=0; k<3; k++) particles.push(new Particle(e.x, e.y, e.color, 5));
                    }
                    noisePos = { x: e.x, y: e.y }; Audio.hit();
                    if (e.hp <= 0 && !e.dead) {
                        if (e.type === 'boss') {
                            if (!e.dying) { e.dying = true; e.dyingTimer = 0; }
                            bullets.splice(j, 1); 
                        } else {
                            e.dead = true;
                            killEnemy(e, b.angle);
                            enemies.splice(i, 1); 
                            hitStop = 2; 
                        }
                        break; 
                    }
                    if (e.dead) { enemies.splice(i, 1); break; }
                }
            }
            if (enemies[i] && !enemies[i].dead && !enemies[i].dying) {
                const pDist = Math.hypot(enemies[i].x - player.x, enemies[i].y - player.y);
                if (pDist < enemies[i].radius + 15) {
                    if(!godMode) {
                        player.hp -= 10; updateUI(); Audio.playerDamage(); shakeX = (Math.random()-0.5) * 20; shakeY = (Math.random()-0.5) * 20; if (player.hp <= 0) endGame();
                    }
                    const angle = Math.atan2(player.y - enemies[i].y, player.x - enemies[i].x);
                    
                    let kbForce = 10;
                    if (enemies[i].type === 'tank') kbForce = 17.5; 

                    // KNOCKBACK IMPULSE
                    player.vx += Math.cos(angle) * kbForce;
                    player.vy += Math.sin(angle) * kbForce;
                    
                    if (enemies[i].type !== 'boss' && enemies[i].type !== 'tank') { enemies[i].dead = true; enemies.splice(i, 1); }
                    
                    for(let k=0; k<10; k++) particles.push(new Particle(player.x, player.y, '#ff0000', 8));
                }
            }
        }

        if (nukeInPlay) {
            nukeTimer += dt; const pingDelay = Math.max(10, nukeDist / 100 * 3); 
            if (nukeTimer > pingDelay) { nukeTimer = 0; const vol = Math.max(0.1, 1.0 - (nukeDist/1500)); Audio.nukePing(vol); }
        }

        if (particles.length > MAX_PARTICLES) particles.splice(0, particles.length - MAX_PARTICLES);
        for (let i = particles.length - 1; i >= 0; i--) { particles[i].update(dt); if (particles[i].life <= 0) particles.splice(i, 1); }
        for (let i = debris.length - 1; i >= 0; i--) {
            debris[i].update(dt);
            if (debris[i].life <= 0) { chunkManager.drawDebris(debris[i].x, debris[i].y, debris[i].rotation, debris[i].color, debris[i].w, debris[i].h); debris.splice(i, 1); }
        }
        shakeX *= 0.8; shakeY *= 0.8;
    }

    function createExplosion(x, y, isBig = false, isMine = false) {
        shakeX = isBig ? 40 : 20; shakeY = isBig ? 40 : 20; 
        if (isMine) Audio.mineExplode(); else Audio.explode();
        
        const pCount = isBig ? 60 : 30;
        for(let i=0; i<pCount; i++) particles.push(new Particle(x, y, '#ffaa00', isBig ? 15 : 10));
        
        const range = isBig ? 250 : 150;
        for (let i = enemies.length - 1; i >= 0; i--) {
            let e = enemies[i]; const dist = Math.hypot(e.x - x, e.y - y);
            if (dist < range) {
                const damage = (1 - (dist/range)) * (isBig ? 60 : 30); e.hp -= damage;
                const angle = Math.atan2(e.y - y, e.x - x);
                const forceMult = e.type === 'boss' ? 0.05 : 1.0;
                const force = (1 - (dist/range)) * 30 * forceMult * (isBig ? 1.5 : 1.0);
                e.vx += Math.cos(angle) * force; e.vy += Math.sin(angle) * force;
                if (e.hp <= 0 && !e.dead && !e.dying) { 
                    if (e.type === 'boss') { e.dying = true; e.dyingTimer = 0; }
                    else { e.dead = true; killEnemy(e, angle); }
                }
            }
        }
    }

    function killEnemy(e, angle, silent = false) {
        score++; if (score > highScore) highScore = score;
        
        let pts = 1;
        if (e.type === 'flanker' || e.type === 'tank') pts = 3;
        if (e.type === 'boss') pts = 500;
        points += pts;

        // SLOWER WAVE PROGRESSION
        if (score % KILLS_PER_WAVE === 0) {
            wave++;
            if (wave < 10) { arena.targetW = Math.min(WORLD_SIZE - 200, ARENA_START_SIZE + (wave * ARENA_GROWTH)); arena.targetH = Math.min(WORLD_SIZE - 200, ARENA_START_SIZE + (wave * ARENA_GROWTH)); }
            
            // SPECIAL WAVE EVENTS
            if (wave === 10) for(let i=0; i<5; i++) enemies.push(new Enemy('flanker')); // Flanker Swarm Start
            if (wave === 15) for(let i=0; i<6; i++) enemies.push(new Enemy('blind')); // Blind Swarm Start
            
            // BOSS SPAWN EVERY 10 WAVES STARTING 20
            if (wave >= 20 && wave % 10 === 0) enemies.push(new Enemy('boss'));

            // BIG SPECIAL EVENT WAVES (25, 35, 45...)
            if (wave >= 25 && (wave - 5) % 10 === 0) {
                 for(let i=0; i<3; i++) enemies.push(new Enemy('tank'));
                 for(let i=0; i<5; i++) enemies.push(new Enemy('flanker'));
                 for(let i=0; i<5; i++) enemies.push(new Enemy('blind'));
            }

            updateUI();
        }
        updateUI();
        if (!silent) { if (e.type === 'tank') Audio.tankDeath(); else Audio.squish(); }
        
        let drop = false; let baseChance = player.weapon === 'pistol' ? 0.25 : 0.12;
        if (e.type === 'tank') drop = true; else if (Math.random() < baseChance) drop = true;
        
        if (drop) {
            // NEW DROP LOGIC
            const rand = Math.random();
            if (rand < 0.3) {
                // 30% Medikit
                pickups.push(new Pickup(e.x, e.y, 'medikit'));
            } else if (rand < 0.4) {
                // 10% Secondary (Reduced from 20%)
                let sChoices = ['mine'];
                if (wave >= 10) sChoices.push('turret');
                if (wave >= 20) sChoices.push('cluster');
                const pick = sChoices[Math.floor(Math.random() * sChoices.length)];
                pickups.push(new Pickup(e.x, e.y, pick));
            } else {
                // 60% Primary
                 let choices = []; 
                if (wave < 5) choices = ['smg', 'shotgun']; 
                else if (wave < 10) choices = ['smg', 'shotgun', 'rocket']; 
                else if (wave < 15) choices = ['smg', 'shotgun', 'rocket', 'minigun'];
                else choices = ['minigun', 'rocket', 'railgun']; 
                
                if (choices.includes(player.weapon)) {
                    choices.push(player.weapon);
                    choices.push(player.weapon);
                }
                const pick = choices[Math.floor(Math.random() * choices.length)]; 
                pickups.push(new Pickup(e.x, e.y, pick));
            }
        } 
        else if (Math.random() < 0.05) pickups.push(new Pickup(e.x, e.y, 'medikit'));
        
        const gibCount = e.type === 'tank' ? 12 : 5;
        for(let i=0; i<gibCount; i++) debris.push(new Debris(e.x, e.y, e.color));
        chunkManager.drawDebris(e.x, e.y, angle, '#660000', 15, 5);
    }

    function endGame() {
        isGameRunning = false;
        document.getElementById('game-over').style.display = 'block';
        document.getElementById('final-kills').innerText = score;
        document.getElementById('final-points').innerText = points;
    }

    function drawWeapon(ctx, type) {
        ctx.fillStyle = '#666'; 
        switch(type) {
            case 'pistol':
                ctx.fillStyle = '#666'; ctx.fillRect(0, -3, 20, 6);
                ctx.fillStyle = '#ffaa00'; ctx.fillRect(5, -1, 10, 2);
                break;
            case 'smg':
                ctx.fillStyle = '#555'; ctx.fillRect(0, -5, 22, 10);
                ctx.fillStyle = '#333'; ctx.fillRect(8, 5, 6, 8); // Mag
                ctx.fillStyle = '#ffffaa'; ctx.fillRect(18, -2, 4, 4);
                break;
            case 'shotgun':
                ctx.fillStyle = '#a0522d'; ctx.fillRect(-5, -6, 20, 12); // Lighter Wood stock
                ctx.fillStyle = '#555'; ctx.fillRect(10, -5, 20, 4); // Lighter Barrel 1
                ctx.fillStyle = '#555'; ctx.fillRect(10, 1, 20, 4); // Lighter Barrel 2
                ctx.fillStyle = '#222'; ctx.fillRect(8, -6, 4, 12); // Action
                break;
            case 'minigun':
                ctx.fillStyle = '#222'; ctx.fillRect(-5, -10, 20, 20); // Body
                ctx.fillStyle = '#444'; ctx.fillRect(15, -8, 20, 16); // Barrel housing
                // Barrels
                ctx.fillStyle = '#111';
                if (Math.floor(Date.now()/50)%2===0) {
                     ctx.fillRect(15, -8, 25, 4); ctx.fillRect(15, 4, 25, 4);
                } else {
                     ctx.fillRect(15, -4, 25, 8);
                }
                break;
            case 'rocket':
                ctx.fillStyle = '#3a4a3a'; ctx.fillRect(-5, -8, 40, 16); // Tube
                ctx.fillStyle = '#1a2a1a'; ctx.fillRect(30, -9, 5, 18); // Muzzle
                ctx.fillStyle = '#ff4444'; ctx.fillRect(5, -3, 30, 6); // Detail
                break;
            case 'railgun':
                // Stock/Body
                ctx.fillStyle = '#333'; ctx.fillRect(-5, -6, 20, 12);
                // Rails
                ctx.fillStyle = '#999';
                ctx.fillRect(15, -8, 30, 4); // Top Rail
                ctx.fillRect(15, 4, 30, 4);  // Bottom Rail
                // Glowing Core
                ctx.fillStyle = '#0ff';
                ctx.shadowBlur = 10; ctx.shadowColor = '#0ff';
                ctx.fillRect(15, -2, 28, 4);
                ctx.shadowBlur = 0;
                // Coil rings
                ctx.fillStyle = '#444';
                ctx.fillRect(25, -9, 4, 18);
                ctx.fillRect(35, -9, 4, 18);
                break;
        }
    }

    function draw() {
        ctx.fillStyle = '#050505';
        ctx.fillRect(0, 0, width, height);
        
        ctx.save();
        const camX = camera.x + shakeX;
        const camY = camera.y + shakeY;
        ctx.translate(-camX, -camY);

        ctx.strokeStyle = '#121212';
        ctx.lineWidth = 2;
        ctx.beginPath();
        const startX = Math.floor(camX / 50) * 50; const endX = startX + width + 50;
        const startY = Math.floor(camY / 50) * 50; const endY = startY + height + 50;
        for(let x = startX; x <= endX; x += 50) { ctx.moveTo(x, camY); ctx.lineTo(x, camY + height); }
        for(let y = startY; y <= endY; y += 50) { ctx.moveTo(camX, y); ctx.lineTo(camX + width, y); }
        ctx.stroke();

        chunkManager.render(ctx, {x: camX, y: camY});

        ctx.strokeStyle = '#331111'; ctx.lineWidth = 8; ctx.strokeRect(arena.x, arena.y, arena.w, arena.h);
        ctx.strokeStyle = '#ff3333'; ctx.lineWidth = 2; ctx.globalAlpha = 0.5 + Math.sin(Date.now() / 200) * 0.2; ctx.strokeRect(arena.x, arena.y, arena.w, arena.h); ctx.globalAlpha = 1.0;

        // BOTTOM LAYER
        corpses.forEach(c => c.draw(ctx));
        mines.forEach(m => m.draw(ctx));
        pickups.forEach(p => p.draw(ctx));
        debris.forEach(d => d.draw(ctx));
        
        // MID LAYER
        grenades.forEach(g => g.draw(ctx));
        turrets.forEach(t => t.draw(ctx));
        enemies.forEach(e => e.draw(ctx));
        bullets.forEach(b => b.draw(ctx));

        ctx.save();
        ctx.translate(player.x, player.y); ctx.rotate(player.angle);
        ctx.fillStyle = '#44ff44'; ctx.shadowBlur = 0; 
        ctx.beginPath(); ctx.arc(0, 0, 15, 0, Math.PI*2); ctx.fill();
        drawWeapon(ctx, player.weapon);
        ctx.restore();

        particles.forEach(p => p.draw(ctx));
        ctx.restore();
        
        for(let p of pickups) {
            if (p.type === 'nuke') {
                const screenX = p.x - camX; const screenY = p.y - camY;
                if (screenX < 0 || screenX > width || screenY < 0 || screenY > height) {
                    const cx = width/2; const cy = height/2; const angle = Math.atan2(screenY - cy, screenX - cx);
                    let tx = cx + Math.cos(angle) * width; let ty = cy + Math.sin(angle) * height;
                    if (tx < 30) tx = 30; if (tx > width-30) tx = width-30; if (ty < 30) ty = 30; if (ty > height-30) ty = height-30;
                    ctx.save(); ctx.translate(tx, ty); ctx.rotate(angle);
                    const pulse = 1 + Math.sin(Date.now() / 100) * 0.2; ctx.scale(pulse, pulse);
                    ctx.fillStyle = '#ffff00'; ctx.beginPath(); ctx.moveTo(10, 0); ctx.lineTo(-10, 10); ctx.lineTo(-10, -10); ctx.fill();
                    ctx.fillStyle = '#000'; ctx.font = '12px Arial'; ctx.textAlign = 'right'; ctx.fillText('NUKE', -15, 4);
                    ctx.restore();
                }
            }
        }
    }

    function loop(time) {
        update(time);
        draw();
        if (isGameRunning) requestAnimationFrame(loop);
    }
</script>
</body>
</html>
